<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë‚˜ë¼ ëë§ì‡ê¸°</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 1;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .game-mode {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        .mode-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .mode-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        .mode-btn.active {
            background: #764ba2;
        }
        .search-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 999;
            background: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease;
            max-height: 50vh;
            overflow-y: auto;
        }
        .search-overlay.show {
            display: block;
        }
        .search-panel {
            background: white;
            border-radius: 0 0 20px 20px;
            padding: 20px 30px 30px 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            margin: 0 auto;
            animation: slideDown 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        .search-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .search-header h2 {
            margin: 0;
            color: #333;
        }
        .close-btn {
            background: #ff6b6b;
            padding: 8px 16px;
            font-size: 14px;
        }
        .close-btn:hover {
            background: #ee5a5a;
        }
        .game-area {
            margin-bottom: 30px;
        }
        .game-layout {
            display: grid;
            grid-template-columns: 300px 1fr 350px;
            gap: 25px;
            margin-top: 20px;
            max-width: 1600px;
            margin-left: auto;
            margin-right: auto;
        }
        .left-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            height: fit-content;
            position: sticky;
            top: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .right-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            height: fit-content;
            position: sticky;
            top: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .stats-section {
            margin-bottom: 0;
        }
        .stats-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e0e0e0;
        }
        .stat-item:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: #666;
            font-size: 14px;
        }
        .stat-value {
            color: #333;
            font-weight: bold;
            font-size: 16px;
        }
        .win-rate {
            font-size: 28px;
            color: #667eea;
            font-weight: bold;
            text-align: center;
            margin: 15px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border: 2px solid #667eea;
        }
        .game-info-section {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #e0e0e0;
        }
        .game-info-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        .info-item {
            padding: 8px 0;
            font-size: 14px;
            color: #666;
        }
        .info-item strong {
            color: #333;
            font-weight: bold;
        }
        .current-turn {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
            color: #1976d2;
        }
        .center-panel {
            min-width: 0;
        }
        .turn-selection {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f4ff;
            border-radius: 8px;
        }
        .turn-btn {
            padding: 10px 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            color: #667eea;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        .turn-btn:hover {
            background: #667eea;
            color: white;
        }
        .turn-btn.selected {
            background: #667eea;
            color: white;
        }
        .turn-btn:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .turn-btn:disabled:hover {
            background: #ccc;
            color: #666;
            transform: none;
        }
        .input-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 15px 20px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
            border-top: 2px solid #667eea;
        }
        .input-container .input-group {
            max-width: 1600px;
            margin: 0 auto;
        }
        .center-panel {
            padding-bottom: 20px;
        }
        .hamburger-menu {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            font-size: 24px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        .hamburger-menu:hover {
            background: #5568d3;
        }
        .panel-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
        }
        .panel-overlay.show {
            display: block;
        }
        .mobile-panel {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 280px;
            background: white;
            z-index: 999;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
        }
        .mobile-panel.show {
            transform: translateX(0);
        }
        .mobile-panel.left {
            left: 0;
        }
        .mobile-panel.right {
            right: 0;
            transform: translateX(100%);
        }
        .mobile-panel.right.show {
            transform: translateX(0);
        }
        .panel-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .panel-toggle-btn {
            display: none;
            padding: 10px 15px;
            margin: 10px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        @media (max-width: 1400px) {
            .game-layout {
                grid-template-columns: 280px 1fr 320px;
            }
        }
        @media (max-width: 1200px) {
            .game-layout {
                grid-template-columns: 250px 1fr 280px;
            }
        }
        @media (max-width: 900px) {
            .hamburger-menu {
                display: block;
            }
            .panel-toggle-btn {
                display: block;
            }
            .game-layout {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            .left-panel,
            .right-panel {
                display: none;
            }
        .center-panel {
            padding-bottom: 20px;
        }
            .available-countries-list {
                max-height: 400px;
            }
            .input-container {
                padding: 12px 15px;
            }
            .input-container .input-group {
                flex-direction: column;
                gap: 10px;
            }
            .input-container button {
                width: 100%;
            }
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        input[type="text"] {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: #667eea;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        button:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .history {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .history-item {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 5px;
        }
        .history-item.user {
            background: #e3f2fd;
            text-align: right;
        }
        .history-item.computer {
            background: #fff3e0;
        }
        .message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
        }
        .message.success {
            background: #c8e6c9;
            color: #2e7d32;
        }
        .message.error {
            background: #ffcdd2;
            color: #c62828;
        }
        .message.info {
            background: #bbdefb;
            color: #1565c0;
        }
        .search-results {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        .country-tag {
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            text-align: center;
            font-size: 14px;
        }
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .controls button {
            font-size: 14px;
            padding: 10px 16px;
        }
        .controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        @media (max-width: 900px) {
            .controls {
                flex-direction: column;
            }
            .controls button {
                width: 100%;
            }
        }
        .available-countries-section {
            padding: 0;
            background: transparent;
            border: none;
        }
        .available-countries-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .available-countries-header h3 {
            margin: 0;
            color: #333;
            font-size: 18px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
            width: 100%;
        }
        .available-countries-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        .available-country-tag {
            background: #9e9e9e;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            text-align: center;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .available-country-tag:hover {
            background: #757575;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .available-country-tag.non-loop {
            background: #667eea;
            color: white;
        }
        .available-country-tag.non-loop:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒ ë‚˜ë¼ ëë§ì‡ê¸°</h1>
        <button class="hamburger-menu" onclick="toggleLeftPanel()" id="hamburgerBtn">â˜°</button>
        <div class="game-mode">
            <button class="mode-btn active">ì»´í“¨í„°ì™€ í”Œë ˆì´</button>
            <button class="mode-btn" onclick="openSearch()">ğŸ” ë‚˜ë¼ ê²€ìƒ‰</button>
        </div>
        <div id="gameArea" class="game-area">
            <div id="difficultySelection" class="turn-selection" style="margin-bottom: 15px;">
                <div style="margin-right: 20px; line-height: 40px; font-weight: bold;">ë‚œì´ë„:</div>
                <button class="turn-btn selected" onclick="selectDifficulty('easy')" id="difficultyBtnEasy">ì‰¬ì›€</button>
                <button class="turn-btn" onclick="selectDifficulty('normal')" id="difficultyBtnNormal">ë³´í†µ</button>
                <button class="turn-btn" onclick="selectDifficulty('hard')" id="difficultyBtnHard">ì–´ë ¤ì›€</button>
                <button class="turn-btn" onclick="selectDifficulty('hell')" id="difficultyBtnHell">ì§€ì˜¥</button>
            </div>
            <div id="turnSelection" class="turn-selection">
                <div style="margin-right: 20px; line-height: 40px; font-weight: bold;">ì„ ê³µ/í›„ê³µ ì„ íƒ:</div>
                <button class="turn-btn selected" onclick="selectTurn('user')" id="turnBtnUser">ë‚˜ ë¨¼ì € (ì„ ê³µ)</button>
                <button class="turn-btn" onclick="selectTurn('computer')" id="turnBtnComputer">ì»´í“¨í„° ë¨¼ì € (í›„ê³µ)</button>
            </div>
            <div id="message" class="message info">ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”! ë‚˜ë¼ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.</div>
            <div class="game-layout">
                <div class="left-panel" id="leftPanel">
                    <div class="stats-section">
                        <h3>ğŸ“Š ìŠ¹ë¥  í†µê³„</h3>
                        <div class="win-rate" id="winRate">0%</div>
                        <div class="stat-item">
                            <span class="stat-label">ìŠ¹ë¦¬</span>
                            <span class="stat-value" id="wins">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">íŒ¨ë°°</span>
                            <span class="stat-value" id="losses">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">ì´ ê²Œì„</span>
                            <span class="stat-value" id="totalGames">0</span>
                        </div>
                    </div>
                    <div class="game-info-section">
                        <h3>ğŸ® í˜„ì¬ ê²Œì„</h3>
                        <div class="info-item">
                            <strong>ì‚¬ìš©ëœ ë‚˜ë¼:</strong> <span id="usedCount">0</span>ê°œ
                        </div>
                        <div class="info-item">
                            <strong>ë§ˆì§€ë§‰ ë‚˜ë¼:</strong> <span id="lastCountryDisplay">-</span>
                        </div>
                        <div class="info-item">
                            <strong>ë‹¤ìŒ ì´ˆì„±:</strong> <span id="nextInitialDisplay">-</span>
                        </div>
                        <div class="current-turn" id="currentTurnDisplay">
                            í˜„ì¬ ì°¨ë¡€: ë‚˜
                        </div>
                    </div>
                </div>
                <div class="center-panel">
                    <div class="controls">
                        <button onclick="startNewGame()">ìƒˆ ê²Œì„</button>
                        <button onclick="undoMove()" id="undoBtn">ë¬´ë¥´ê¸°</button>
                        <button onclick="surrender()" id="surrenderBtn" style="background-color: #dc3545;">ê¸°ê¶Œ</button>
                        <button onclick="exportGameHistory()" id="exportBtn">ê¸°ë¡ ì €ì¥</button>
                        <button onclick="trainAIModel()" id="trainBtn" style="background-color: #17a2b8;">AI ëª¨ë¸ í•™ìŠµ</button>
                        <button onclick="toggleAutoLearning()" id="autoLearningBtn" style="background-color: #9c27b0; color: white;">ğŸ¤– ìë™ í•™ìŠµ ëª¨ë“œ: OFF</button>
                        <button onclick="clearTrainingData()" id="clearDataBtn" style="background-color: #6c757d;">ë°ì´í„° ì´ˆê¸°í™”</button>
                    </div>
                    <div class="history" id="history"></div>
                </div>
                <div class="right-panel" id="rightPanel">
                    <div class="available-countries-section" id="availableCountriesSection">
                        <div class="available-countries-header">
                            <h3>ğŸ“‹ ë‹¤ìŒì— ê°€ëŠ¥í•œ ë‚˜ë¼ë“¤</h3>
                        </div>
                        <div class="info-item" style="margin-bottom: 10px; font-size: 13px; color: #666;">
                            ì´ <strong id="availableCount">0</strong>ê°œ ê°€ëŠ¥
                        </div>
                        <div class="available-countries-list" id="availableCountriesList"></div>
                    </div>
                    <div class="game-info-section">
                        <h3>ğŸ¤– AI í•™ìŠµ ì •ë³´</h3>
                        <div class="info-item">
                            <strong>ìˆ˜ì§‘ëœ ë°ì´í„°:</strong> <span id="trainingDataCount">0</span>ê°œ
                        </div>
                        <div class="info-item">
                            <strong>ëª¨ë¸ ìƒíƒœ:</strong> <span id="modelStatus">ì—†ìŒ</span>
                        </div>
                        <div class="info-item" id="autoLearningStatus" style="display: none;">
                            <strong>ìë™ í•™ìŠµ:</strong> <span id="autoGameCountDisplay">0</span>ê²Œì„ ì§„í–‰ ì¤‘<br>
                            <span style="font-size: 12px; color: #666;">ë³„ë„ ê³µê°„ì—ì„œ ì‹¤í–‰ ì¤‘</span>
                        </div>
                        <div class="info-item" style="font-size: 12px; color: #666; margin-top: 10px;">
                            <strong>ê²Œì„ ë°©ë²•:</strong><br>
                            ì˜¤ë¥¸ìª½ "ë‹¤ìŒì— ê°€ëŠ¥í•œ ë‚˜ë¼ë“¤" ëª©ë¡ì—ì„œ ë‚˜ë¼ë¥¼ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”.
                        </div>
                        <div class="info-item" style="font-size: 12px; color: #666; margin-top: 10px;">
                            <strong>ìë™ í•™ìŠµ ëª¨ë“œ:</strong><br>
                            "ìë™ í•™ìŠµ ëª¨ë“œ" ë²„íŠ¼ì„ í´ë¦­í•˜ë©´ ì–‘ìª½ AIê°€ ìë™ìœ¼ë¡œ ê²Œì„ì„ ì§„í–‰í•˜ë©° ë¹ ë¥´ê²Œ í•™ìŠµí•©ë‹ˆë‹¤.
                        </div>
                    </div>
                    <div class="game-info-section">
                        <h3>ğŸ’¡ ê²Œì„ íŒ</h3>
                        <div class="info-item" style="font-size: 13px; line-height: 1.6;">
                            <strong>ğŸ”„ ëºê¸° ì‹œìŠ¤í…œ:</strong><br>
                            í›„ê³µë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. ì„ ê³µì´ ì²« ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ë©´, ê·¸ ë‹¨ì–´ê°€ ìŠ¹ë¦¬í•  ê°€ëŠ¥ì„±ì´ ë†’ì„ ë•Œ "ëºê¸°" ë²„íŠ¼ì„ ëˆŒëŸ¬ ê·¸ ë‹¨ì–´ë¥¼ ë‹¤ì‹œ ì…ë ¥í•˜ë©´ ì°¨ë¡€ê°€ ë°”ë€ë‹ˆë‹¤. ì´ì œ ë‹¹ì‹ ì´ ì„ ê³µì´ ë©ë‹ˆë‹¤!<br><br>
                            <strong>ì „ëµ íŒ:</strong>
                            â€¢ ã„·~ã„±ì´ í•˜ë‚˜ ë¹ ì§€ë©´ ã„·ì´ ì´ê¹ë‹ˆë‹¤.<br>
                            â€¢ ã„¹~ã…‡ì´ í•˜ë‚˜ ë¹ ì§€ë©´ ã„¹ì´ ì´ê¹ë‹ˆë‹¤.<br>
                            â€¢ ã…‡ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë‚˜ë¼ê°€ ê°€ì¥ ë§ìœ¼ë©°, ê³µê²©ì´ ê°€ì¥ ë§ìŠµë‹ˆë‹¤!
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="panel-overlay" id="panelOverlay" onclick="closeAllPanels()"></div>
        <div class="mobile-panel left" id="mobileLeftPanel">
            <button class="panel-close" onclick="closeLeftPanel()">Ã—</button>
            <div class="left-panel" style="position: static; padding: 20px;">
                <div class="stats-section">
                    <h3>ğŸ“Š ìŠ¹ë¥  í†µê³„</h3>
                    <div class="win-rate" id="winRateMobile">0%</div>
                    <div class="stat-item">
                        <span class="stat-label">ìŠ¹ë¦¬</span>
                        <span class="stat-value" id="winsMobile">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">íŒ¨ë°°</span>
                        <span class="stat-value" id="lossesMobile">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ì´ ê²Œì„</span>
                        <span class="stat-value" id="totalGamesMobile">0</span>
                    </div>
                </div>
                <div class="game-info-section">
                    <h3>ğŸ® í˜„ì¬ ê²Œì„</h3>
                    <div class="info-item">
                        <strong>ì‚¬ìš©ëœ ë‚˜ë¼:</strong> <span id="usedCountMobile">0</span>ê°œ
                    </div>
                    <div class="info-item">
                        <strong>ë§ˆì§€ë§‰ ë‚˜ë¼:</strong> <span id="lastCountryDisplayMobile">-</span>
                    </div>
                    <div class="info-item">
                        <strong>ë‹¤ìŒ ì´ˆì„±:</strong> <span id="nextInitialDisplayMobile">-</span>
                    </div>
                    <div class="current-turn" id="currentTurnDisplayMobile">
                        í˜„ì¬ ì°¨ë¡€: ë‚˜
                    </div>
                </div>
            </div>
        </div>
        <div class="mobile-panel right" id="mobileRightPanel">
            <button class="panel-close" onclick="closeRightPanel()">Ã—</button>
            <div class="right-panel" style="position: static; padding: 20px;">
                <div class="available-countries-section" id="availableCountriesSectionMobile">
                    <div class="available-countries-header">
                        <h3>ğŸ“‹ ë‹¤ìŒì— ê°€ëŠ¥í•œ ë‚˜ë¼ë“¤</h3>
                    </div>
                    <div class="info-item" style="margin-bottom: 10px; font-size: 13px; color: #666;">
                        ì´ <strong id="availableCountMobile">0</strong>ê°œ ê°€ëŠ¥
                    </div>
                    <div class="available-countries-list" id="availableCountriesListMobile"></div>
                </div>
                <div class="game-info-section">
                    <h3>ğŸ’¡ ê²Œì„ íŒ</h3>
                    <div class="info-item" style="font-size: 13px; line-height: 1.6;">
                        <strong>ğŸ”„ ëºê¸° ì‹œìŠ¤í…œ:</strong><br>
                        í›„ê³µë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. ì„ ê³µì´ ì²« ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ë©´, ê·¸ ë‹¨ì–´ê°€ ìŠ¹ë¦¬í•  ê°€ëŠ¥ì„±ì´ ë†’ì„ ë•Œ "ëºê¸°" ë²„íŠ¼ì„ ëˆŒëŸ¬ ê·¸ ë‹¨ì–´ë¥¼ ë‹¤ì‹œ ì…ë ¥í•˜ë©´ ì°¨ë¡€ê°€ ë°”ë€ë‹ˆë‹¤. ì´ì œ ë‹¹ì‹ ì´ ì„ ê³µì´ ë©ë‹ˆë‹¤!<br><br>
                        <strong>ì „ëµ íŒ:</strong>
                        â€¢ ã„·~ã„±ì´ í•˜ë‚˜ ë¹ ì§€ë©´ ã„·ì´ ì´ê¹ë‹ˆë‹¤.<br>
                        â€¢ ã„¹~ã…‡ì´ í•˜ë‚˜ ë¹ ì§€ë©´ ã„¹ì´ ì´ê¹ë‹ˆë‹¤.<br>
                        â€¢ ã…‡ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë‚˜ë¼ê°€ ê°€ì¥ ë§ìœ¼ë©°, ê³µê²©ì´ ê°€ì¥ ë§ìŠµë‹ˆë‹¤!
                    </div>
                </div>
            </div>
        </div>
        <div class="input-container" style="display: none;">
            <!-- ì…ë ¥ ì°½ ì œê±°ë¨ - ì‚¬ìš© ê°€ëŠ¥í•œ ë‚˜ë¼ ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš” -->
        </div>
        <div id="searchOverlay" class="search-overlay" onclick="closeSearch(event)">
            <div class="search-panel" onclick="event.stopPropagation()">
                <div class="search-header">
                    <h2>ğŸ” ë‚˜ë¼ ê²€ìƒ‰</h2>
                    <button class="close-btn" onclick="closeSearch()">ë‹«ê¸°</button>
                </div>
                <div class="input-group">
                    <input type="text" id="searchInput" placeholder="ììŒì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: ã„±, ã„´, ã„·...)" maxlength="1" onkeyup="searchCountries()" autofocus>
                </div>
                <div class="search-results" id="searchResults"></div>
            </div>
        </div>
    </div>
    <script>
        // TensorFlow.js AI ëª¨ë¸ ê´€ë ¨ ë³€ìˆ˜
        let aiModel = null;
        let isTraining = false;
        let trainingData = [];
        let dataCollectionEnabled = true; // í•­ìƒ í™œì„±í™”
        let aiModeEnabled = true; // í•­ìƒ í™œì„±í™”
        let lastAutoTrainCount = 0; // ë§ˆì§€ë§‰ ìë™ í•™ìŠµ ì‹œì ì˜ ë°ì´í„° ê°œìˆ˜
        let autoLearningMode = false; // ìë™ í•™ìŠµ ëª¨ë“œ
        let autoLearningInterval = null; // ìë™ í•™ìŠµ ì¸í„°ë²Œ
        let autoGameCount = 0; // ìë™ ê²Œì„ íšŸìˆ˜
        
        // ìë™ í•™ìŠµìš© ë³„ë„ ê²Œì„ ìƒíƒœ (í”Œë ˆì´ì–´ ê²Œì„ê³¼ ë¶„ë¦¬)
        const autoGameState = {
            usedCountries: [],
            lastCountry: null,
            gameEnded: false,
            firstTurnDone: false,
            firstTurnCountry: null,
            currentPlayer: 'user',
            firstPlayer: 'user'
        };
        const autoGameHistory = []; // ìë™ í•™ìŠµìš© ë³„ë„ íˆìŠ¤í† ë¦¬
        
        const INITIALS = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
        
        // ìë™ í•™ìŠµ ëª¨ë“œ í† ê¸€
        function toggleAutoLearning() {
            autoLearningMode = !autoLearningMode;
            const btn = document.getElementById('autoLearningBtn');
            
            if (autoLearningMode) {
                btn.textContent = 'ğŸ¤– ìë™ í•™ìŠµ ëª¨ë“œ: ON';
                btn.style.backgroundColor = '#7b1fa2';
                showMessage('ìë™ í•™ìŠµ ëª¨ë“œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ì–‘ìª½ AIê°€ ìë™ìœ¼ë¡œ ê²Œì„ì„ ì§„í–‰í•©ë‹ˆë‹¤.', 'success');
                startAutoLearning();
            } else {
                btn.textContent = 'ğŸ¤– ìë™ í•™ìŠµ ëª¨ë“œ: OFF';
                btn.style.backgroundColor = '#9c27b0';
                stopAutoLearning();
                showMessage('ìë™ í•™ìŠµ ëª¨ë“œê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
            }
        }
        
        // ìë™ í•™ìŠµ ì‹œì‘
        function startAutoLearning() {
            if (autoLearningInterval) {
                return; // ì´ë¯¸ ì‹¤í–‰ ì¤‘
            }
            
            // ì²« ê²Œì„ ì‹œì‘
            startAutoGame();
        }
        
        // ìë™ í•™ìŠµ ì¤‘ì§€
        function stopAutoLearning() {
            if (autoLearningInterval) {
                clearTimeout(autoLearningInterval);
                autoLearningInterval = null;
            }
            autoGameCount = 0;
        }
        
        // ìë™ ê²Œì„ ì‹œì‘ (ì–‘ìª½ AIê°€ í”Œë ˆì´) - ë³„ë„ ê²Œì„ ìƒíƒœ ì‚¬ìš©
        function startAutoGame() {
            if (!autoLearningMode) {
                return;
            }
            
            // ìë™ í•™ìŠµìš© ë³„ë„ ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (í”Œë ˆì´ì–´ ê²Œì„ê³¼ ë¶„ë¦¬)
            autoGameState.usedCountries = [];
            autoGameState.lastCountry = null;
            autoGameState.gameEnded = false;
            autoGameState.firstTurnDone = false;
            autoGameState.firstTurnCountry = null;
            autoGameState.currentPlayer = Math.random() > 0.5 ? 'user' : 'computer';
            autoGameState.firstPlayer = autoGameState.currentPlayer;
            autoGameHistory.length = 0;
            
            // ì²« ìˆ˜ ì§„í–‰
            autoPlayTurn();
        }
        
        // ìë™ìœ¼ë¡œ í•œ í„´ ì§„í–‰ (ë³„ë„ ê²Œì„ ìƒíƒœ ì‚¬ìš©)
        function autoPlayTurn() {
            if (!autoLearningMode || autoGameState.gameEnded) {
                // ê²Œì„ ì¢…ë£Œ ì‹œ ë‹¤ìŒ ê²Œì„ ì‹œì‘
                if (autoLearningMode) {
                    autoGameCount++;
                    updateModelStatus(); // ìƒíƒœ ì—…ë°ì´íŠ¸
                    
                    // ë¹ ë¥¸ í•™ìŠµì„ ìœ„í•´ ì£¼ê¸°ì ìœ¼ë¡œ í•™ìŠµ (ë¹„ë™ê¸°ë¡œ ì‹¤í–‰í•˜ì—¬ ê²Œì„ ì§„í–‰ ë°©í•´ ì•ˆ í•¨)
                    if (!isTraining && trainingData.length >= 20 && trainingData.length - lastAutoTrainCount >= 20) {
                        // ë¹„ë™ê¸°ë¡œ í•™ìŠµ ì‹œì‘ (ê²Œì„ ì§„í–‰ì€ ê³„ì†ë¨)
                        trainModelFast(10).then(() => {
                            updateModelStatus();
                        }).catch(err => {
                            console.error('ìë™ í•™ìŠµ ì˜¤ë¥˜:', err);
                        });
                    }
                    
                    // ë‹¤ìŒ ê²Œì„ ì‹œì‘ (ì¦‰ì‹œ)
                    setTimeout(() => {
                        startAutoGame();
                    }, 10);
                }
                return;
            }
            
            // ìë™ í•™ìŠµìš© ë³„ë„ ê²Œì„ ìƒíƒœ ì‚¬ìš©
            const available = getAvailableCountries(autoGameState.usedCountries, autoGameState.lastCountry);
            
            if (available.length === 0) {
                // ê²Œì„ ì¢…ë£Œ
                autoGameState.gameEnded = true;
                autoPlayTurn(); // ë‹¤ìŒ ê²Œì„ ì‹œì‘
                return;
            }
            
            // AIê°€ ë‚˜ë¼ ì„ íƒ (ëœë¤ ë˜ëŠ” í•™ìŠµëœ ëª¨ë¸ ì‚¬ìš©)
            let choice;
            if (aiModel && Math.random() > 0.3) {
                // 70% í™•ë¥ ë¡œ í•™ìŠµëœ ëª¨ë¸ ì‚¬ìš©
                choice = aiChooseCountry(available, autoGameState.usedCountries, autoGameState.lastCountry);
            }
            
            if (!choice) {
                // ëª¨ë¸ì´ ì—†ê±°ë‚˜ ì„ íƒ ì‹¤íŒ¨ ì‹œ ëœë¤ ì„ íƒ
                choice = available[Math.floor(Math.random() * available.length)];
            }
            
            // ë°ì´í„° ìˆ˜ì§‘ (ìë™ í•™ìŠµ ë°ì´í„°)
            if (dataCollectionEnabled) {
                const prevUsed = autoGameState.usedCountries.slice();
                const prevLast = autoGameState.lastCountry;
                collectGameData(choice, prevUsed, prevLast, available);
            }
            
            // ìë™ í•™ìŠµìš© ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ (í”Œë ˆì´ì–´ ê²Œì„ ìƒíƒœì™€ ë¶„ë¦¬)
            autoGameState.usedCountries.push(choice);
            autoGameState.lastCountry = choice;
            autoGameState.currentPlayer = autoGameState.currentPlayer === 'user' ? 'computer' : 'user';
            
            if (!autoGameState.firstTurnDone) {
                autoGameState.firstTurnDone = true;
                if (autoGameState.firstPlayer === autoGameState.currentPlayer) {
                    autoGameState.firstTurnCountry = choice;
                }
            }
            
            // ìë™ í•™ìŠµìš© íˆìŠ¤í† ë¦¬ ì¶”ê°€ (í”Œë ˆì´ì–´ íˆìŠ¤í† ë¦¬ì™€ ë¶„ë¦¬)
            autoGameHistory.push({
                country: choice,
                player: autoGameState.currentPlayer === 'user' ? 'computer' : 'user',
                usedCountries: [...autoGameState.usedCountries],
                lastCountry: autoGameState.lastCountry,
                currentPlayer: autoGameState.currentPlayer,
                firstTurnDone: autoGameState.firstTurnDone,
                firstTurnCountry: autoGameState.firstTurnCountry,
                gameEnded: autoGameState.gameEnded
            });
            
            // ë‹¤ìŒ í„´ ì§„í–‰ (ì¦‰ì‹œ, ë”œë ˆì´ ì—†ìŒ)
            setTimeout(() => {
                autoPlayTurn();
            }, 0);
        }
        
        // ë¹ ë¥¸ í•™ìŠµ (ì ì€ ì—í¬í¬ë¡œ ë¹ ë¥´ê²Œ í•™ìŠµ)
        async function trainModelFast(epochs = 10) {
            if (trainingData.length < 10) {
                return false;
            }
            
            if (isTraining) {
                return false;
            }
            
            isTraining = true;
            
            try {
                if (!aiModel) {
                    aiModel = createModel();
                } else {
                    // ëª¨ë¸ì´ ë¡œë“œëœ ê²½ìš° ì»´íŒŒì¼ ìƒíƒœ í™•ì¸ ë° ì¬ì»´íŒŒì¼
                    if (!aiModel.optimizer) {
                        aiModel.compile({
                            optimizer: tf.train.adam(0.001),
                            loss: 'categoricalCrossentropy',
                            metrics: ['accuracy']
                        });
                    }
                }
                
                const { xs, ys } = prepareTrainingData();
                
                // ë¹ ë¥¸ í•™ìŠµì„ ìœ„í•´ ì‘ì€ ë°°ì¹˜ ì‚¬ì´ì¦ˆ ì‚¬ìš©
                const batchSize = Math.min(16, Math.max(4, Math.floor(trainingData.length / 4)));
                
                // ë¹„ë™ê¸°ë¡œ í•™ìŠµ ì‹¤í–‰ (ê²Œì„ ì§„í–‰ ë°©í•´ ìµœì†Œí™”)
                await aiModel.fit(xs, ys, {
                    epochs: epochs,
                    batchSize: batchSize,
                    validationSplit: 0.1,
                    verbose: 0, // ë¡œê·¸ ìµœì†Œí™”
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            // ë¡œê·¸ ìµœì†Œí™”
                        }
                    }
                });
                
                xs.dispose();
                ys.dispose();
                
                // ëª¨ë¸ ì €ì¥ (ë¹„ë™ê¸°ë¡œ ì‹¤í–‰í•˜ì—¬ ê²Œì„ ì§„í–‰ ë°©í•´ ì•ˆ í•¨)
                saveModel().catch(err => console.error('ëª¨ë¸ ì €ì¥ ì˜¤ë¥˜:', err));
                
                lastAutoTrainCount = trainingData.length;
                isTraining = false;
                
                return true;
            } catch (error) {
                console.error('ë¹ ë¥¸ í•™ìŠµ ì˜¤ë¥˜:', error);
                isTraining = false;
                return false;
            }
        }
        
        // AI íŒ¨ë°° ì‹œ ì „ëµ ë¶„ì„
        function analyzeDefeatStrategy() {
            const analysis = {
                strategies: [],
                criticalMoves: [],
                patternAnalysis: {}
            };
            
            // 1. ì´ˆì„± ì „ëµ ë¶„ì„
            const dToGCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã„·' && last === 'ã„±';
            }).length;
            const gToDCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã„±' && last === 'ã„·';
            }).length;
            const dWinSituation = (dToGCount - gToDCount) > 0;
            
            const rToYCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã„¹' && last === 'ã…‡';
            }).length;
            const yToRCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã…‡' && last === 'ã„¹';
            }).length;
            const rWinSituation = (rToYCount - yToRCount) > 0;
            
            if (dWinSituation && !gameState.usedCountries.includes('ê·¸ë ˆë‚˜ë‹¤')) {
                analysis.strategies.push({
                    type: 'ã„·-ã„± ì „ëµ',
                    description: 'í”Œë ˆì´ì–´ê°€ ã„·â†’ã„± ì „ëµì„ ì‚¬ìš©í•˜ì—¬ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤.',
                    details: `ã„·â†’ã„± ì‚¬ìš©: ${dToGCount}ê°œ, ã„±â†’ã„· ì‚¬ìš©: ${gToDCount}ê°œ, ì°¨ì´: ${dToGCount - gToDCount}ê°œ`,
                    impact: 'high'
                });
            }
            
            if (rWinSituation) {
                analysis.strategies.push({
                    type: 'ã„¹-ã…‡ ì „ëµ',
                    description: 'í”Œë ˆì´ì–´ê°€ ã„¹â†’ã…‡ ì „ëµì„ ì‚¬ìš©í•˜ì—¬ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤.',
                    details: `ã„¹â†’ã…‡ ì‚¬ìš©: ${rToYCount}ê°œ, ã…‡â†’ã„¹ ì‚¬ìš©: ${yToRCount}ê°œ, ì°¨ì´: ${rToYCount - yToRCount}ê°œ`,
                    impact: 'high'
                });
            }
            
            // 2. ë§ˆì§€ë§‰ í„´ ë¶„ì„
            if (gameState.lastCountry) {
                const lastInitial = getLastCharInitial(gameState.lastCountry);
                const available = getAvailableCountries(gameState.usedCountries, gameState.lastCountry);
                
                if (available.length === 0) {
                    analysis.criticalMoves.push({
                        move: gameState.lastCountry,
                        reason: `"${gameState.lastCountry}"ë¥¼ ì„ íƒí•˜ì—¬ AIê°€ ${lastInitial}ë¡œ ì‹œì‘í•˜ëŠ” ë‚˜ë¼ë¥¼ ì°¾ì§€ ëª»í•˜ê²Œ í–ˆìŠµë‹ˆë‹¤.`,
                        impact: 'critical'
                    });
                }
                
                // íŠ¹ì • ì´ˆì„±ìœ¼ë¡œ ëë‚˜ëŠ” ë‚˜ë¼ê°€ ë¶€ì¡±í•œì§€ í™•ì¸
                const endingCounts = {};
                INITIALS.forEach(initial => {
                    const count = COUNTRY_NAMES.filter(c => 
                        getLastCharInitial(c) === initial && 
                        !gameState.usedCountries.includes(c)
                    ).length;
                    endingCounts[initial] = count;
                });
                
                const lowEndingCounts = Object.entries(endingCounts)
                    .filter(([initial, count]) => count <= 2 && count > 0)
                    .sort((a, b) => a[1] - b[1]);
                
                if (lowEndingCounts.length > 0) {
                    analysis.patternAnalysis.lowEndingCounts = lowEndingCounts.map(([initial, count]) => ({
                        initial,
                        count,
                        description: `${initial}ë¡œ ëë‚˜ëŠ” ë‚˜ë¼ê°€ ${count}ê°œë§Œ ë‚¨ì•˜ìŠµë‹ˆë‹¤.`
                    }));
                }
            }
            
            // 3. ê²Œì„ íˆìŠ¤í† ë¦¬ ë¶„ì„ - ì¤‘ìš”í•œ ì „í™˜ì  ì°¾ê¸°
            const userMoves = gameHistory.filter(h => h.player === 'user');
            const computerMoves = gameHistory.filter(h => h.player === 'computer');
            
            // ì‚¬ìš©ìê°€ ì„ íƒí•œ ë‚˜ë¼ë“¤ì˜ íŒ¨í„´ ë¶„ì„
            const userEndings = userMoves.map(move => getLastCharInitial(move.country));
            const endingFrequency = {};
            userEndings.forEach(ending => {
                endingFrequency[ending] = (endingFrequency[ending] || 0) + 1;
            });
            
            const mostFrequentEndings = Object.entries(endingFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3);
            
            if (mostFrequentEndings.length > 0) {
                analysis.patternAnalysis.frequentEndings = mostFrequentEndings.map(([initial, count]) => ({
                    initial,
                    count,
                    description: `í”Œë ˆì´ì–´ê°€ ${initial}ë¡œ ëë‚˜ëŠ” ë‚˜ë¼ë¥¼ ${count}ë²ˆ ì„ íƒí–ˆìŠµë‹ˆë‹¤.`
                }));
            }
            
            // 4. ëºê¸° ì „ëµ ì‚¬ìš© ì—¬ë¶€
            const stealMoves = gameHistory.filter(h => h.country.includes('ëºê¸°'));
            if (stealMoves.length > 0) {
                analysis.strategies.push({
                    type: 'ëºê¸° ì „ëµ',
                    description: 'í”Œë ˆì´ì–´ê°€ ëºê¸° ì „ëµì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.',
                    details: `ëºê¸° ì‚¬ìš© íšŸìˆ˜: ${stealMoves.length}íšŒ`,
                    impact: 'medium'
                });
            }
            
            // 5. íŠ¹ì • ë‚˜ë¼ ì‚¬ìš© íŒ¨í„´
            const grenadaUsed = gameState.usedCountries.includes('ê·¸ë ˆë‚˜ë‹¤');
            const guatemalaUsed = gameState.usedCountries.includes('ê³¼í…Œë§ë¼');
            
            if (grenadaUsed) {
                analysis.criticalMoves.push({
                    move: 'ê·¸ë ˆë‚˜ë‹¤',
                    reason: 'ê·¸ë ˆë‚˜ë‹¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ã„·â†’ã„± ë£¨í”„ë¥¼ ê¹¨ëœ¨ë ¸ìŠµë‹ˆë‹¤.',
                    impact: 'high'
                });
            }
            
            if (guatemalaUsed) {
                analysis.criticalMoves.push({
                    move: 'ê³¼í…Œë§ë¼',
                    reason: 'ê³¼í…Œë§ë¼ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ˆì „í•œ ì‹œì‘ì„ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.',
                    impact: 'medium'
                });
            }
            
            return analysis;
        }
        
        // ì „ëµ ë¶„ì„ ê²°ê³¼ í‘œì‹œ
        function displayStrategyAnalysis(analysis) {
            let analysisText = 'ğŸ“Š AI íŒ¨ë°° ì „ëµ ë¶„ì„\n';
            analysisText += '='.repeat(40) + '\n\n';
            
            if (analysis.strategies.length > 0) {
                analysisText += 'ğŸ¯ ì‚¬ìš©ëœ ì „ëµ:\n';
                analysis.strategies.forEach((strategy, idx) => {
                    analysisText += `${idx + 1}. [${strategy.type}] ${strategy.description}\n`;
                    analysisText += `   ${strategy.details}\n\n`;
                });
            }
            
            if (analysis.criticalMoves.length > 0) {
                analysisText += 'âš¡ ì¤‘ìš”í•œ ìˆ˜:\n';
                analysis.criticalMoves.forEach((move, idx) => {
                    analysisText += `${idx + 1}. "${move.move}": ${move.reason}\n\n`;
                });
            }
            
            if (analysis.patternAnalysis.frequentEndings) {
                analysisText += 'ğŸ“ˆ íŒ¨í„´ ë¶„ì„:\n';
                analysis.patternAnalysis.frequentEndings.forEach(pattern => {
                    analysisText += `- ${pattern.description}\n`;
                });
                analysisText += '\n';
            }
            
            if (analysis.patternAnalysis.lowEndingCounts) {
                analysisText += 'âš ï¸ ìœ„í—˜í•œ ì´ˆì„±:\n';
                analysis.patternAnalysis.lowEndingCounts.forEach(pattern => {
                    analysisText += `- ${pattern.description}\n`;
                });
                analysisText += '\n';
            }
            
            analysisText += '='.repeat(40);
            
            // ëª¨ë‹¬ë¡œ í‘œì‹œ
            showStrategyAnalysisModal(analysisText, analysis);
        }
        
        // ì „ëµ ë¶„ì„ ëª¨ë‹¬ í‘œì‹œ
        function showStrategyAnalysisModal(text, analysis) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.7);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                animation: fadeIn 0.3s ease;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 30px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            `;
            
            const title = document.createElement('h2');
            title.textContent = 'ğŸ¤– AI íŒ¨ë°° ì „ëµ ë¶„ì„';
            title.style.cssText = 'margin: 0 0 20px 0; color: #333;';
            
            const textArea = document.createElement('pre');
            textArea.textContent = text;
            textArea.style.cssText = `
                white-space: pre-wrap;
                font-family: 'Malgun Gothic', sans-serif;
                font-size: 14px;
                line-height: 1.6;
                color: #333;
                background: #f5f5f5;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            `;
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'ë‹«ê¸°';
            closeBtn.style.cssText = `
                padding: 10px 20px;
                background: #667eea;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
            `;
            closeBtn.onclick = () => {
                document.body.removeChild(modal);
            };
            
            content.appendChild(title);
            content.appendChild(textArea);
            content.appendChild(closeBtn);
            modal.appendChild(content);
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
            
            document.body.appendChild(modal);
        }
        
        // AI ëª¨ë¸ í•™ìŠµ ì‹œì‘
        async function trainAIModel() {
            if (isTraining) {
                showMessage('ì´ë¯¸ í•™ìŠµì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.', 'error');
                return;
            }
            
            if (trainingData.length < 10) {
                showMessage(`í•™ìŠµ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. í˜„ì¬ ${trainingData.length}ê°œ, ìµœì†Œ 10ê°œ í•„ìš”í•©ë‹ˆë‹¤.`, 'error');
                return;
            }
            
            const epochs = parseInt(prompt(`í•™ìŠµ ì—í¬í¬ ìˆ˜ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ê¸°ë³¸ê°’: 50):`, '50')) || 50;
            
            // ë²„íŠ¼ ë¹„í™œì„±í™”
            const trainBtn = document.getElementById('trainBtn');
            const originalText = trainBtn.textContent;
            trainBtn.disabled = true;
            trainBtn.textContent = 'í•™ìŠµ ì¤‘...';
            
            const success = await trainModel(epochs);
            
            // ë²„íŠ¼ í™œì„±í™”
            trainBtn.disabled = false;
            trainBtn.textContent = originalText;
            
            if (success) {
                updateModelStatus();
            }
        }
        
        // AI ëª¨ë¸ ìƒì„±
        function createModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({
                        inputShape: [78], // íŠ¹ì§• ë²¡í„° í¬ê¸° (1 + 19 + 19 + 19 + 19 + 1 = 78)
                        units: 128,
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }),
                    tf.layers.dropout({ rate: 0.3 }),
                    tf.layers.dense({
                        units: 64,
                        activation: 'relu'
                    }),
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({
                        units: COUNTRY_NAMES.length,
                        activation: 'softmax'
                    })
                ]
            });
            
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }
        
        // ê²Œì„ ìƒíƒœë¥¼ íŠ¹ì§• ë²¡í„°ë¡œ ë³€í™˜
        function gameStateToFeatures(usedCountries, lastCountry, availableCountries) {
            const features = new Array(78).fill(0); // ì‹¤ì œ íŠ¹ì§• ë²¡í„° í¬ê¸°: 78
            let idx = 0;
            
            // ì‚¬ìš©ëœ ë‚˜ë¼ ìˆ˜ (ì •ê·œí™”)
            features[idx++] = Math.min(usedCountries.length / COUNTRY_NAMES.length, 1.0);
            
            // ë§ˆì§€ë§‰ ë‚˜ë¼ì˜ ì´ˆì„± (one-hot encoding)
            if (lastCountry) {
                const lastInitial = getLastCharInitial(lastCountry);
                const lastInitialIdx = INITIALS.indexOf(lastInitial);
                if (lastInitialIdx >= 0) {
                    features[idx + lastInitialIdx] = 1.0;
                }
            }
            idx += 19;
            
            // ë‹¤ìŒ ì´ˆì„± (one-hot encoding)
            if (lastCountry) {
                const nextInitial = getLastCharInitial(lastCountry);
                const nextInitialIdx = INITIALS.indexOf(nextInitial);
                if (nextInitialIdx >= 0) {
                    features[idx + nextInitialIdx] = 1.0;
                }
            }
            idx += 19;
            
            // ê° ì´ˆì„±ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë‚˜ë¼ì˜ ì‚¬ìš© ë¹„ìœ¨
            INITIALS.forEach(initial => {
                const total = COUNTRY_NAMES.filter(c => getFirstCharInitial(c) === initial).length;
                const used = usedCountries.filter(c => getFirstCharInitial(c) === initial).length;
                features[idx++] = total > 0 ? used / total : 0;
            });
            
            // ê° ì´ˆì„±ìœ¼ë¡œ ëë‚˜ëŠ” ë‚˜ë¼ì˜ ì‚¬ìš© ë¹„ìœ¨
            INITIALS.forEach(initial => {
                const total = COUNTRY_NAMES.filter(c => getLastCharInitial(c) === initial).length;
                const used = usedCountries.filter(c => getLastCharInitial(c) === initial).length;
                features[idx++] = total > 0 ? used / total : 0;
            });
            
            // ì‚¬ìš© ê°€ëŠ¥í•œ ë‚˜ë¼ ìˆ˜ (ì •ê·œí™”)
            features[idx++] = Math.min(availableCountries.length / COUNTRY_NAMES.length, 1.0);
            
            return features;
        }
        
        // ë‚˜ë¼ ì´ë¦„ì„ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
        function countryToIndex(country) {
            return COUNTRY_NAMES.indexOf(country);
        }
        
        // ì¸ë±ìŠ¤ë¥¼ ë‚˜ë¼ ì´ë¦„ìœ¼ë¡œ ë³€í™˜
        function indexToCountry(index) {
            return COUNTRY_NAMES[index];
        }
        
        // ê²Œì„ ë°ì´í„° ìˆ˜ì§‘
        function collectGameData(country, usedCountries, lastCountry, availableCountries) {
            const features = gameStateToFeatures(usedCountries, lastCountry, availableCountries);
            const countryIndex = countryToIndex(country);
            
            if (countryIndex >= 0) {
                trainingData.push({
                    features: features,
                    label: countryIndex
                });
            }
        }
        
        // í•™ìŠµ ë°ì´í„° ì¤€ë¹„
        function prepareTrainingData() {
            if (trainingData.length === 0) {
                return { xs: null, ys: null };
            }
            
            const xs = [];
            const ys = [];
            
            trainingData.forEach(data => {
                xs.push(data.features);
                const label = new Array(COUNTRY_NAMES.length).fill(0);
                label[data.label] = 1;
                ys.push(label);
            });
            
            return {
                xs: tf.tensor2d(xs),
                ys: tf.tensor2d(ys)
            };
        }
        
        // ëª¨ë¸ í•™ìŠµ
        async function trainModel(epochs = 50) {
            if (trainingData.length < 10) {
                showMessage('í•™ìŠµ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ìµœì†Œ 10ê°œì˜ ë°ì´í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤.', 'error');
                return false;
            }
            
            isTraining = true;
            showMessage(`ëª¨ë¸ í•™ìŠµ ì¤‘... (${trainingData.length}ê°œ ë°ì´í„°, ${epochs} ì—í¬í¬)`, 'info');
            
            try {
                if (!aiModel) {
                    aiModel = createModel();
                } else {
                    // ëª¨ë¸ì´ ë¡œë“œëœ ê²½ìš° ì»´íŒŒì¼ ìƒíƒœ í™•ì¸ ë° ì¬ì»´íŒŒì¼
                    if (!aiModel.optimizer) {
                        aiModel.compile({
                            optimizer: tf.train.adam(0.001),
                            loss: 'categoricalCrossentropy',
                            metrics: ['accuracy']
                        });
                    }
                }
                
                const { xs, ys } = prepareTrainingData();
                
                await aiModel.fit(xs, ys, {
                    epochs: epochs,
                    batchSize: Math.min(32, Math.floor(trainingData.length / 2)),
                    validationSplit: 0.2,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            if ((epoch + 1) % 10 === 0) {
                                console.log(`Epoch ${epoch + 1}: loss = ${logs.loss.toFixed(4)}, accuracy = ${logs.acc ? logs.acc.toFixed(4) : 'N/A'}`);
                            }
                        }
                    }
                });
                
                xs.dispose();
                ys.dispose();
                
                // ëª¨ë¸ ì €ì¥
                await saveModel();
                
                isTraining = false;
                showMessage(`ëª¨ë¸ í•™ìŠµ ì™„ë£Œ! (${trainingData.length}ê°œ ë°ì´í„°ë¡œ í•™ìŠµ)`, 'success');
                return true;
            } catch (error) {
                console.error('í•™ìŠµ ì˜¤ë¥˜:', error);
                isTraining = false;
                showMessage('ëª¨ë¸ í•™ìŠµ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                return false;
            }
        }
        
        // ëª¨ë¸ ì €ì¥
        async function saveModel() {
            try {
                const modelData = await aiModel.save('indexeddb://country-game-model');
                console.log('ëª¨ë¸ ì €ì¥ ì™„ë£Œ');
            } catch (error) {
                console.error('ëª¨ë¸ ì €ì¥ ì˜¤ë¥˜:', error);
            }
        }
        
        // ëª¨ë¸ ë¡œë“œ
        async function loadModel() {
            try {
                aiModel = await tf.loadLayersModel('indexeddb://country-game-model');
                
                // ëª¨ë¸ì˜ ì…ë ¥ í¬ê¸° í™•ì¸
                const inputShape = aiModel.inputs[0].shape;
                if (inputShape && inputShape[1] !== 78) {
                    console.log('ê¸°ì¡´ ëª¨ë¸ì˜ ì…ë ¥ í¬ê¸°ê°€ ë§ì§€ ì•ŠìŠµë‹ˆë‹¤. ëª¨ë¸ì„ ì¬ìƒì„±í•©ë‹ˆë‹¤.');
                    // ê¸°ì¡´ ëª¨ë¸ ì‚­ì œ
                    try {
                        await tf.io.removeModel('indexeddb://country-game-model');
                    } catch (e) {
                        console.log('ëª¨ë¸ ì‚­ì œ ì˜¤ë¥˜:', e);
                    }
                    aiModel = null;
                    updateModelStatus();
                    return false;
                }
                
                // ëª¨ë¸ì´ ë¡œë“œë˜ì—ˆì§€ë§Œ ì»´íŒŒì¼ë˜ì§€ ì•Šì€ ê²½ìš° ì¬ì»´íŒŒì¼
                if (!aiModel.optimizer) {
                    console.log('ëª¨ë¸ ì»´íŒŒì¼ ì¤‘...');
                    aiModel.compile({
                        optimizer: tf.train.adam(0.001),
                        loss: 'categoricalCrossentropy',
                        metrics: ['accuracy']
                    });
                }
                
                console.log('ëª¨ë¸ ë¡œë“œ ì™„ë£Œ');
                updateModelStatus();
                return true;
            } catch (error) {
                console.log('ì €ì¥ëœ ëª¨ë¸ì´ ì—†ìŠµë‹ˆë‹¤:', error);
                updateModelStatus();
                return false;
            }
        }
        
        // ëª¨ë¸ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateModelStatus() {
            const statusEl = document.getElementById('modelStatus');
            if (statusEl) {
                if (aiModel) {
                    statusEl.textContent = 'ë¡œë“œë¨';
                    statusEl.style.color = '#28a745';
                } else {
                    statusEl.textContent = 'ì—†ìŒ';
                    statusEl.style.color = '#666';
                }
            }
            const countEl = document.getElementById('trainingDataCount');
            if (countEl) {
                countEl.textContent = trainingData.length;
            }
            
            // ìë™ í•™ìŠµ ìƒíƒœ ì—…ë°ì´íŠ¸
            const autoStatusEl = document.getElementById('autoLearningStatus');
            const autoGameCountEl = document.getElementById('autoGameCountDisplay');
            if (autoLearningMode) {
                if (autoStatusEl) autoStatusEl.style.display = 'block';
                if (autoGameCountEl) autoGameCountEl.textContent = autoGameCount;
            } else {
                if (autoStatusEl) autoStatusEl.style.display = 'none';
            }
        }
        
        // í•™ìŠµ ë°ì´í„° ì´ˆê¸°í™”
        function clearTrainingData() {
            if (confirm('ìˆ˜ì§‘ëœ í•™ìŠµ ë°ì´í„°ë¥¼ ëª¨ë‘ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                trainingData = [];
                updateModelStatus();
                showMessage('í•™ìŠµ ë°ì´í„°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
            }
        }
        
        // AI ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ë‚˜ë¼ ì„ íƒ
        function aiChooseCountry(availableCountries, usedCountries, lastCountry) {
            if (!aiModel || availableCountries.length === 0) {
                return null;
            }
            
            try {
                const features = gameStateToFeatures(usedCountries, lastCountry, availableCountries);
                const input = tf.tensor2d([features]);
                
                const prediction = aiModel.predict(input);
                const probabilities = prediction.dataSync();
                
                input.dispose();
                prediction.dispose();
                
                // ì‚¬ìš© ê°€ëŠ¥í•œ ë‚˜ë¼ ì¤‘ì—ì„œ ê°€ì¥ ë†’ì€ í™•ë¥ ì„ ê°€ì§„ ë‚˜ë¼ ì„ íƒ
                let bestCountry = null;
                let bestProb = -1;
                
                availableCountries.forEach(country => {
                    const idx = countryToIndex(country);
                    if (idx >= 0 && probabilities[idx] > bestProb) {
                        bestProb = probabilities[idx];
                        bestCountry = country;
                    }
                });
                
                return bestCountry || availableCountries[Math.floor(Math.random() * availableCountries.length)];
            } catch (error) {
                console.error('AI ì˜ˆì¸¡ ì˜¤ë¥˜:', error);
                return null;
            }
        }
        
        const COUNTRY_NAMES = [
            "ê°€ë‚˜", "ê°€ë´‰", "ê°€ì´ì•„ë‚˜", "ê°ë¹„ì•„", "ê³¼í…Œë§ë¼", "ê·¸ë ˆë‚˜ë‹¤", "ê·¸ë¦¬ìŠ¤", "ê¸°ë‹ˆ", "ê¸°ë‹ˆë¹„ì‚¬ìš°",
            "ë‚˜ë¯¸ë¹„ì•„", "ë‚˜ìš°ë£¨", "ë‚˜ì´ì§€ë¦¬ì•„", "ë‚¨ìˆ˜ë‹¨", "ë‚¨ì•„í”„ë¦¬ì¹´ê³µí™”êµ­", "ë„¤ëœë€ë“œ", "ë„¤íŒ”", "ë…¸ë¥´ì›¨ì´", "ë‰´ì§ˆëœë“œ", "ë‹ˆì œë¥´", "ë‹ˆì¹´ë¼ê³¼",
            "ëŒ€í•œë¯¼êµ­", "ë´ë§ˆí¬", "ë„ë¯¸ë‹ˆì¹´ì—°ë°©", "ë„ë¯¸ë‹ˆì¹´ê³µí™”êµ­", "ë…ì¼", "ë™í‹°ëª¨ë¥´",
            "ë¼ì˜¤ìŠ¤", "ë¼ì´ë² ë¦¬ì•„", "ë¼íŠ¸ë¹„ì•„", "ëŸ¬ì‹œì•„", "ë ˆë°”ë…¼", "ë ˆì†Œí† ", "ë£¨ë§ˆë‹ˆì•„", "ë£©ì…ˆë¶€ë¥´í¬", "ë¥´ì™„ë‹¤", "ë¦¬ë¹„ì•„", "ë¦¬íˆ¬ì•„ë‹ˆì•„", "ë¦¬íˆí…ìŠˆíƒ€ì¸",
            "ë§ˆë‹¤ê°€ìŠ¤ì¹´ë¥´", "ë§ˆì…œì œë„", "ë§ˆì¼€ë„ë‹ˆì•„", "ë§ë¼ìœ„", "ë§ë ˆì´ì‹œì•„", "ë§ë¦¬", "ë©•ì‹œì½”", "ëª¨ë‚˜ì½”", "ëª¨ë¡œì½”", "ëª¨ë¦¬ì…”ìŠ¤", "ëª¨ë¦¬íƒ€ë‹ˆ", "ëª¨ì ë¹„í¬", "ëª¬í…Œë„¤ê·¸ë¡œ", "ëª°ë„ë°”", "ëª°ë””ë¸Œ", "ëª°íƒ€", "ëª½ê³¨", "ë¯¸êµ­", "ë¯¸ì–€ë§ˆ", "ë¯¸í¬ë¡œë„¤ì‹œì•„",
            "ë°”ëˆ„ì•„íˆ¬", "ë°”ë ˆì¸", "ë°”ë² ì´ë„ìŠ¤", "ë°”í•˜ë§ˆ", "ë°©ê¸€ë¼ë°ì‹œ", "ë² ëƒ‰", "ë² ë„¤ìˆ˜ì—˜ë¼", "ë² íŠ¸ë‚¨", "ë²¨ê¸°ì—", "ë²¨ë¼ë£¨ìŠ¤", "ë²¨ë¦¬ì¦ˆ", "ë³´ìŠ¤ë‹ˆì•„í—¤ë¥´ì²´ê³ ë¹„ë‚˜", "ë³´ì¸ ì™€ë‚˜", "ë³¼ë¦¬ë¹„ì•„", "ë¶€ë£¬ë””", "ë¶€ë¥´í‚¤ë‚˜íŒŒì†Œ", "ë¶€íƒ„", "ë¶ˆê°€ë¦¬ì•„", "ë¸Œë¼ì§ˆ", "ë¸Œë£¨ë‚˜ì´",
            "ì‚¬ëª¨ì•„", "ì‚¬ìš°ë””ì•„ë¼ë¹„ì•„", "ì‚°ë§ˆë¦¬ë…¸", "ìƒíˆ¬ë©”í”„ë¦°ì‹œí˜", "ì„¸ë„¤ê°ˆ", "ì„¸ë¥´ë¹„ì•„", "ì„¸ì´ì…¸", "ì„¸ì¸íŠ¸í‚¤ì¸ ë„¤ë¹„ìŠ¤", "ì„¸ì¸íŠ¸ë£¨ì‹œì•„", "ì„¸ì¸íŠ¸ë¹ˆì„¼íŠ¸ê·¸ë ˆë‚˜ë”˜", "ì†Œë§ë¦¬ì•„", "ì†”ë¡œëª¬ì œë„", "ìˆ˜ë‹¨", "ìˆ˜ë¦¬ë‚¨", "ìŠ¤ë¦¬ë‘ì¹´", "ìŠ¤ì›¨ë´", "ìŠ¤ìœ„ìŠ¤", "ìŠ¤í˜ì¸", "ìŠ¬ë¡œë°”í‚¤ì•„", "ìŠ¬ë¡œë² ë‹ˆì•„", "ì‹œë¦¬ì•„", "ì‹œì—ë¼ë¦¬ì˜¨", "ì‹±ê°€í¬ë¥´",
            "ì•„ëì—ë¯¸ë¦¬íŠ¸", "ì•„ë¥´ë©”ë‹ˆì•„", "ì•„ë¥´í—¨í‹°ë‚˜", "ì•„ì´ìŠ¬ë€ë“œ", "ì•„ì¼ëœë“œ", "ì•„ì œë¥´ë°”ì´ì”", "ì•„í”„ê°€ë‹ˆìŠ¤íƒ„", "ì•ˆë„ë¼", "ì•Œë°”ë‹ˆì•„", "ì•Œì œë¦¬", "ì•™ê³¨ë¼", "ì•¤í‹°ê°€ë°”ë¶€ë‹¤", "ì—ë¦¬íŠ¸ë ˆì•„", "ì—ìŠ¤ì™€í‹°ë‹ˆ", "ì—ìŠ¤í† ë‹ˆì•„", "ì—ì½°ë„ë¥´", "ì—í‹°ì˜¤í”¼ì•„", "ì—˜ì‚´ë°”ë„ë¥´", "ì˜êµ­", "ì˜ˆë©˜", "ì˜¤ë§Œ", "ì˜¤ìŠ¤íŠ¸ë ˆì¼ë¦¬ì•„", "ì˜¤ìŠ¤íŠ¸ë¦¬ì•„", "ì˜¨ë‘ë¼ìŠ¤", "ìš”ë¥´ë‹¨", "ìš°ê°„ë‹¤", "ìš°ë£¨ê³¼ì´", "ìš°ì¦ˆë² í‚¤ìŠ¤íƒ„", "ìš°í¬ë¼ì´ë‚˜", "ì´ë¼í¬", "ì´ë€", "ì´ìŠ¤ë¼ì—˜", "ì´ì§‘íŠ¸", "ì´íƒˆë¦¬ì•„", "ì¸ë„", "ì¸ë„ë„¤ì‹œì•„", "ì¼ë³¸",
            "ìë©”ì´ì¹´", "ì ë¹„ì•„", "ì ë„ê¸°ë‹ˆ", "ì¡°ì„ ë¯¼ì£¼ì£¼ì˜ì¸ë¯¼ê³µí™”êµ­", "ì¡°ì§€ì•„", "ì¤‘ì•™ì•„í”„ë¦¬ì¹´ê³µí™”êµ­", "ì¤‘êµ­", "ì§€ë¶€í‹°", "ì§ë°”ë¸Œì›¨",
            "ì°¨ë“œ", "ì²´ì½”", "ì¹ ë ˆ",
            "ì¹´ë©”ë£¬", "ì¹´ë³´ë² ë¥´ë°", "ì¹´ìíìŠ¤íƒ„", "ì¹´íƒ€ë¥´", "ìº„ë³´ë””ì•„", "ìºë‚˜ë‹¤", "ì¼€ëƒ", "ì½”ëª¨ë¡œ", "ì½”ìŠ¤íƒ€ë¦¬ì¹´", "ì½”íŠ¸ë””ë¶€ì•„ë¥´", "ì½œë¡¬ë¹„ì•„", "ì½©ê³ ê³µí™”êµ­", "ì½©ê³ ë¯¼ì£¼ê³µí™”êµ­", "ì¿ ë°”", "ì¿ ì›¨ì´íŠ¸", "í¬ë¡œì•„í‹°ì•„", "í‚¤ë¥´ê¸°ìŠ¤ìŠ¤íƒ„", "í‚¤ë¦¬ë°”ì‹œ", "í‚¤í”„ë¡œìŠ¤",
            "íƒœêµ­", "íƒ€ì§€í‚¤ìŠ¤íƒ„", "íƒ„ìë‹ˆì•„", "í„°í‚¤", "í† ê³ ", "í†µê°€", "íˆ¬ë¥´í¬ë©”ë‹ˆìŠ¤íƒ„", "íˆ¬ë°œë£¨", "íŠ€ë‹ˆì§€", "íŠ¸ë¦¬ë‹ˆë‹¤ë“œí† ë°”ê³ ",
            "íŒŒë‚˜ë§ˆ", "íŒŒë¼ê³¼ì´", "íŒŒí‚¤ìŠ¤íƒ„", "íŒŒí‘¸ì•„ë‰´ê¸°ë‹ˆ", "íŒ”ë¼ìš°", "í˜ë£¨", "í¬ë¥´íˆ¬ê°ˆ", "í´ë€ë“œ", "í”„ë‘ìŠ¤", "í”¼ì§€", "í•€ë€ë“œ", "í•„ë¦¬í•€",
            "í—ê°€ë¦¬"
        ];
        function getFirstCharInitial(text) {
            if (!text || text.length === 0) return null;
            const firstChar = text[0];
            const charCode = firstChar.charCodeAt(0);
            if (charCode >= 0xAC00 && charCode <= 0xD7A3) {
                const initialIndex = Math.floor((charCode - 0xAC00) / 588);
                const initials = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
                return initials[initialIndex];
            }
            return null;
        }
        function getLastCharInitial(countryName) {
            const lastChar = countryName[countryName.length - 1];
            const charCode = lastChar.charCodeAt(0);
            if (charCode >= 0xAC00 && charCode <= 0xD7A3) {
                const initialIndex = Math.floor((charCode - 0xAC00) / 588);
                const initials = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
                return initials[initialIndex];
            }
            return null;
        }
        function findCountry(name) {
            return COUNTRY_NAMES.find(c => c === name);
        }
        function findCountriesByInitial(initial) {
            return COUNTRY_NAMES.filter(c => getFirstCharInitial(c) === initial);
        }
        function getAvailableCountries(usedCountries, lastCountry) {
            if (!lastCountry) {
                return COUNTRY_NAMES.filter(c => !usedCountries.includes(c));
            }
            const last = findCountry(lastCountry);
            if (!last) return [];
            const nextInitial = getLastCharInitial(last);
            if (!nextInitial) return [];
            return COUNTRY_NAMES.filter(c => 
                getFirstCharInitial(c) === nextInitial && !usedCountries.includes(c)
            );
        }
        const gameState = {
            usedCountries: [],
            lastCountry: null,
            gameMode: 'vsComputer',
            difficulty: 'normal',
            gameEnded: false,
            firstPlayer: 'user', 
            currentPlayer: 'user', 
            firstTurnDone: false, 
            firstTurnCountry: null 
        };
        const gameHistory = [];
        function getStats() {
            const stats = localStorage.getItem('countryGameStats');
            if (stats) {
                return JSON.parse(stats);
            }
            return { wins: 0, losses: 0, totalGames: 0 };
        }
        function saveStats(stats) {
            localStorage.setItem('countryGameStats', JSON.stringify(stats));
        }
        function saveGameState() {
            const stateToSave = {
                usedCountries: gameState.usedCountries,
                lastCountry: gameState.lastCountry,
                gameMode: gameState.gameMode,
                difficulty: gameState.difficulty,
                gameEnded: gameState.gameEnded,
                firstPlayer: gameState.firstPlayer,
                currentPlayer: gameState.currentPlayer,
                firstTurnDone: gameState.firstTurnDone,
                firstTurnCountry: gameState.firstTurnCountry,
                gameHistory: gameHistory
            };
            localStorage.setItem('countryGameState', JSON.stringify(stateToSave));
        }
        function loadGameState() {
            const savedState = localStorage.getItem('countryGameState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    if (state.gameEnded) {
                        return false;
                    }
                    if (state.usedCountries && state.usedCountries.length > 0) {
                        gameState.usedCountries = state.usedCountries;
                        gameState.lastCountry = state.lastCountry;
                        gameState.gameMode = state.gameMode || 'vsComputer';
                        gameState.difficulty = state.difficulty || 'normal';
                        gameState.gameEnded = state.gameEnded || false;
                        gameState.firstPlayer = state.firstPlayer || 'user';
                        gameState.currentPlayer = state.currentPlayer || 'user';
                        gameState.firstTurnDone = state.firstTurnDone || false;
                        gameState.firstTurnCountry = state.firstTurnCountry || null;
                        if (state.gameHistory && state.gameHistory.length > 0) {
                            gameHistory.length = 0;
                            gameHistory.push(...state.gameHistory);
                        }
                        return true;
                    }
                } catch (e) {
                    console.error('ê²Œì„ ìƒíƒœ ë³µì› ì‹¤íŒ¨:', e);
                }
            }
            return false;
        }
        function clearGameState() {
            localStorage.removeItem('countryGameState');
        }
        function updateStatsDisplay() {
            const stats = getStats();
            const winRate = stats.totalGames > 0 
                ? Math.round((stats.wins / stats.totalGames) * 100) 
                : 0;
            document.getElementById('wins').textContent = stats.wins;
            document.getElementById('losses').textContent = stats.losses;
            document.getElementById('totalGames').textContent = stats.totalGames;
            document.getElementById('winRate').textContent = winRate + '%';
            const winsMobile = document.getElementById('winsMobile');
            const lossesMobile = document.getElementById('lossesMobile');
            const totalGamesMobile = document.getElementById('totalGamesMobile');
            const winRateMobile = document.getElementById('winRateMobile');
            if (winsMobile) winsMobile.textContent = stats.wins;
            if (lossesMobile) lossesMobile.textContent = stats.losses;
            if (totalGamesMobile) totalGamesMobile.textContent = stats.totalGames;
            if (winRateMobile) winRateMobile.textContent = winRate + '%';
        }
        function recordWin() {
            const stats = getStats();
            stats.wins++;
            stats.totalGames++;
            saveStats(stats);
            saveGameState();
            updateStatsDisplay();
        }
        function recordLoss() {
            const stats = getStats();
            stats.losses++;
            stats.totalGames++;
            saveStats(stats);
            saveGameState();
            updateStatsDisplay();
        }
        function surrender() {
            if (gameState.gameEnded) {
                showMessage('ì´ë¯¸ ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'error');
                return;
            }
            if (confirm('ì •ë§ ê¸°ê¶Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? íŒ¨ë°°ë¡œ ê¸°ë¡ë©ë‹ˆë‹¤.')) {
                gameState.gameEnded = true;
                showMessage('ğŸ˜¢ ê¸°ê¶Œí•˜ì…¨ìŠµë‹ˆë‹¤. ì»´í“¨í„°ê°€ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!', 'error');
                recordLoss();
                updateGameInfo();
            }
        }
        function computerSurrender() {
            if (gameState.gameEnded) {
                return;
            }
            gameState.gameEnded = true;
            showMessage('ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ì»´í“¨í„°ê°€ ê¸°ê¶Œí–ˆìŠµë‹ˆë‹¤. ë‹¹ì‹ ì´ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!', 'success');
            recordWin();
            updateGameInfo();
        }
        function findSafeFromAttack(available, attackInitial, depth, maxDepth, usedCountries) {
            if (depth >= maxDepth) {
                return [];
            }
            const safe = available.filter(country => {
                const nextAvailable = getAvailableCountries([...usedCountries, country], country);
                return !nextAvailable.some(c => getLastCharInitial(c) === attackInitial);
            });
            if (depth === maxDepth - 1) {
                return safe;
            }
            const results = [];
            for (const country of safe) {
                const nextAvailable = getAvailableCountries([...usedCountries, country], country);
                const deeperSafe = findSafeFromAttack(nextAvailable, attackInitial, depth + 1, maxDepth, [...usedCountries, country]);
                if (deeperSafe.length > 0) {
                    results.push(country);
                }
            }
            return results;
        }
        function isComputerTrapped() {
            const available = getAvailableCountries(gameState.usedCountries, gameState.lastCountry);
            if (available.length === 0) {
                return true;
            }
            const allEndWithDOrR = available.every(country => {
                const lastInitial = getLastCharInitial(country);
                return lastInitial === 'ã„·' || lastInitial === 'ã„¹';
            });
            if (allEndWithDOrR && available.length > 0) {
                return true;
            }
            const grenadaUsed = gameState.usedCountries.includes('ê·¸ë ˆë‚˜ë‹¤');
            const dToGCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã„·' && last === 'ã„±';
            }).length;
            if (dToGCount === 1 && !grenadaUsed) {
                const dEnding = available.filter(c => getLastCharInitial(c) === 'ã„·');
                if (dEnding.length === 0) {
                    return true;
                }
            }
            const rToYCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã„¹' && last === 'ã…‡';
            }).length;
            const yToRCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã…‡' && last === 'ã„¹';
            }).length;
            if (rToYCount - yToRCount > 0) {
                const rEnding = available.filter(c => getLastCharInitial(c) === 'ã„¹');
                if (rEnding.length === 0) {
                    return true;
                }
            }
            return false;
        }
        function exportGameHistory() {
            const historyEl = document.getElementById('history');
            if (!historyEl || historyEl.children.length === 0) {
                showMessage('ì €ì¥í•  ê²Œì„ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.', 'error');
                return;
            }
            let textHistory = 'ë‚˜ë¼ ëë§ì‡ê¸° ê²Œì„ ê¸°ë¡\n';
            textHistory += '='.repeat(30) + '\n\n';
            gameHistory.forEach((item, index) => {
                const playerName = item.player === 'user' ? 'ë‚˜' : 'ì»´í“¨í„°';
                textHistory += `${index + 1}. ${playerName}: ${item.country}\n`;
            });
            textHistory += '\n' + '='.repeat(30) + '\n';
            textHistory += `ì´ ${gameHistory.length}ìˆ˜\n`;
            textHistory += `ì‚¬ìš©ëœ ë‚˜ë¼: ${gameState.usedCountries.length}ê°œ\n`;
            navigator.clipboard.writeText(textHistory).then(() => {
                showMessage('ê²Œì„ ê¸°ë¡ì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
            }).catch(() => {
                const textarea = document.createElement('textarea');
                textarea.value = textHistory;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showMessage('ê²Œì„ ê¸°ë¡ì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
            });
        }
        function selectDifficulty(difficulty) {
            if (gameState.firstTurnDone) {
                showMessage('ê²Œì„ì´ ì‹œì‘ëœ í›„ì—ëŠ” ë‚œì´ë„ë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                return;
            }
            gameState.difficulty = difficulty;
            document.getElementById('difficultyBtnEasy').classList.remove('selected');
            document.getElementById('difficultyBtnNormal').classList.remove('selected');
            document.getElementById('difficultyBtnHard').classList.remove('selected');
            document.getElementById('difficultyBtnHell').classList.remove('selected');
            const difficultyNames = {
                'easy': 'ì‰¬ì›€',
                'normal': 'ë³´í†µ',
                'hard': 'ì–´ë ¤ì›€',
                'hell': 'ì§€ì˜¥'
            };
            document.getElementById('difficultyBtn' + difficulty.charAt(0).toUpperCase() + difficulty.slice(1)).classList.add('selected');
            showMessage(`ë‚œì´ë„ê°€ "${difficultyNames[difficulty]}"ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'info');
        }
        function selectTurn(player) {
            if (gameState.firstTurnDone) {
                showMessage('ê²Œì„ì´ ì‹œì‘ëœ í›„ì—ëŠ” ì„ ê³µ/í›„ê³µì„ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                return;
            }
            gameState.firstPlayer = player;
            gameState.currentPlayer = player;
            document.getElementById('turnBtnUser').classList.remove('selected');
            document.getElementById('turnBtnComputer').classList.remove('selected');
            if (player === 'user') {
                document.getElementById('turnBtnUser').classList.add('selected');
                showMessage('ë‹¹ì‹ ì´ ì„ ê³µì…ë‹ˆë‹¤! ë‚˜ë¼ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'info');
            } else {
                document.getElementById('turnBtnComputer').classList.add('selected');
                showMessage('ì»´í“¨í„°ê°€ ì„ ê³µì…ë‹ˆë‹¤!', 'info');
                setTimeout(() => {
                    computerTurn();
                }, 500);
            }
            if (!gameState.firstTurnDone) {
                const stealSection = document.getElementById('stealSection');
                if (stealSection) {
                    stealSection.style.display = 'none';
                }
            }
        }
        function toggleLeftPanel() {
            const panel = document.getElementById('mobileLeftPanel');
            const overlay = document.getElementById('panelOverlay');
            const rightPanel = document.getElementById('mobileRightPanel');
            if (panel.classList.contains('show')) {
                closeLeftPanel();
            } else {
                rightPanel.classList.remove('show');
                panel.classList.add('show');
                overlay.classList.add('show');
            }
        }
        function toggleRightPanel() {
            const panel = document.getElementById('mobileRightPanel');
            const overlay = document.getElementById('panelOverlay');
            const leftPanel = document.getElementById('mobileLeftPanel');
            if (panel.classList.contains('show')) {
                closeRightPanel();
            } else {
                leftPanel.classList.remove('show');
                panel.classList.add('show');
                overlay.classList.add('show');
            }
        }
        function closeLeftPanel() {
            document.getElementById('mobileLeftPanel').classList.remove('show');
            checkPanelsClosed();
        }
        function closeRightPanel() {
            document.getElementById('mobileRightPanel').classList.remove('show');
            checkPanelsClosed();
        }
        function closeAllPanels() {
            document.getElementById('mobileLeftPanel').classList.remove('show');
            document.getElementById('mobileRightPanel').classList.remove('show');
            document.getElementById('panelOverlay').classList.remove('show');
        }
        function checkPanelsClosed() {
            const leftPanel = document.getElementById('mobileLeftPanel');
            const rightPanel = document.getElementById('mobileRightPanel');
            const overlay = document.getElementById('panelOverlay');
            if (!leftPanel.classList.contains('show') && !rightPanel.classList.contains('show')) {
                overlay.classList.remove('show');
            }
        }
        window.addEventListener('DOMContentLoaded', async function() {
            // TensorFlow.js ë¡œë“œ í™•ì¸
            if (typeof tf === 'undefined') {
                console.error('TensorFlow.jsê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                showMessage('TensorFlow.js ë¡œë“œ ì‹¤íŒ¨. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.', 'error');
            } else {
                console.log('TensorFlow.js ë¡œë“œ ì™„ë£Œ');
                // ì €ì¥ëœ ëª¨ë¸ ë¡œë“œ ì‹œë„
                await loadModel();
            }
            
            const loaded = loadGameState();
            if (loaded) {
                const difficultyNames = {
                    'easy': 'ì‰¬ì›€',
                    'normal': 'ë³´í†µ',
                    'hard': 'ì–´ë ¤ì›€',
                    'hell': 'ì§€ì˜¥'
                };
                document.getElementById('difficultyBtnEasy').classList.remove('selected');
                document.getElementById('difficultyBtnNormal').classList.remove('selected');
                document.getElementById('difficultyBtnHard').classList.remove('selected');
                document.getElementById('difficultyBtnHell').classList.remove('selected');
                document.getElementById('difficultyBtn' + gameState.difficulty.charAt(0).toUpperCase() + gameState.difficulty.slice(1)).classList.add('selected');
                document.getElementById('turnBtnUser').classList.remove('selected');
                document.getElementById('turnBtnComputer').classList.remove('selected');
                if (gameState.firstPlayer === 'user') {
                    document.getElementById('turnBtnUser').classList.add('selected');
                } else {
                    document.getElementById('turnBtnComputer').classList.add('selected');
                }
                if (gameState.firstTurnDone) {
                    disableGameSettings();
                }
                const historyEl = document.getElementById('history');
                historyEl.innerHTML = '';
                gameHistory.forEach(item => {
                    const historyItem = document.createElement('div');
                    historyItem.className = `history-item ${item.player}`;
                    historyItem.textContent = `${item.player === 'user' ? 'ğŸ‘¤ ë‚˜' : 'ğŸ¤– ì»´í“¨í„°'}: ${item.country}`;
                    historyEl.appendChild(historyItem);
                });
                historyEl.scrollTop = historyEl.scrollHeight;
                showMessage('ì´ì „ ê²Œì„ì´ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
            }
            updateUndoButton();
            updateAvailableCountries();
            updateStatsDisplay();
            updateGameInfo();
            updateModelStatus();
        });
        function openSearch() {
            const overlay = document.getElementById('searchOverlay');
            overlay.classList.add('show');
            document.getElementById('searchInput').focus();
            document.body.style.overflow = 'hidden';
        }
        function closeSearch(event) {
            if (event && event.target !== event.currentTarget) {
                return;
            }
            const overlay = document.getElementById('searchOverlay');
            overlay.classList.remove('show');
            document.body.style.overflow = '';
            document.getElementById('searchInput').value = '';
            document.getElementById('searchResults').innerHTML = '';
        }
        function showMessage(text, type) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = `message ${type}`;
        }
        function addToHistory(country, player) {
            const historyEl = document.getElementById('history');
            const item = document.createElement('div');
            item.className = `history-item ${player}`;
            item.textContent = `${player === 'user' ? 'ğŸ‘¤ ë‚˜' : 'ğŸ¤– ì»´í“¨í„°'}: ${country}`;
            historyEl.appendChild(item);
            historyEl.scrollTop = historyEl.scrollHeight;
            gameHistory.push({
                country: country,
                player: player,
                usedCountries: [...gameState.usedCountries],
                lastCountry: gameState.lastCountry,
                currentPlayer: gameState.currentPlayer,
                firstTurnDone: gameState.firstTurnDone,
                firstTurnCountry: gameState.firstTurnCountry,
                gameEnded: gameState.gameEnded
            });
            updateUndoButton();
        }
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            if (gameHistory.length === 0) {
                undoBtn.disabled = true;
                undoBtn.style.opacity = '0.5';
                undoBtn.style.cursor = 'not-allowed';
            } else {
                undoBtn.disabled = false;
                undoBtn.style.opacity = '1';
                undoBtn.style.cursor = 'pointer';
            }
        }
        function undoMove() {
            if (gameHistory.length === 0) {
                showMessage('ë¬´ë¥¼ ìˆ˜ ìˆëŠ” í„´ì´ ì—†ìŠµë‹ˆë‹¤.', 'error');
                return;
            }
            let itemsToRemove = 2;
            if (gameHistory.length < 2) {
                itemsToRemove = gameHistory.length;
            }
            for (let i = 0; i < itemsToRemove; i++) {
                gameHistory.pop();
            }
            if (gameHistory.length === 0) {
                gameState.usedCountries = [];
                gameState.lastCountry = null;
                gameState.currentPlayer = gameState.firstPlayer;
                gameState.firstTurnDone = false;
                gameState.firstTurnCountry = null;
                gameState.gameEnded = false;
            } else {
                const prevState = gameHistory[gameHistory.length - 1];
                gameState.usedCountries = [...prevState.usedCountries];
                gameState.lastCountry = prevState.lastCountry;
                gameState.currentPlayer = prevState.currentPlayer;
                gameState.firstTurnDone = prevState.firstTurnDone;
                gameState.firstTurnCountry = prevState.firstTurnCountry;
                gameState.gameEnded = prevState.gameEnded;
            }
            const historyEl = document.getElementById('history');
            historyEl.innerHTML = '';
            gameHistory.forEach(item => {
                const historyItem = document.createElement('div');
                historyItem.className = `history-item ${item.player}`;
                historyItem.textContent = `${item.player === 'user' ? 'ğŸ‘¤ ë‚˜' : 'ğŸ¤– ì»´í“¨í„°'}: ${item.country}`;
                historyEl.appendChild(historyItem);
            });
            historyEl.scrollTop = historyEl.scrollHeight;
            updateAvailableCountries();
            updateGameInfo();
            updateUndoButton();
            saveGameState();
            showMessage(itemsToRemove === 2 ? 'í•œ í„´ì„ ë¬´ë¥´ê¸°í–ˆìŠµë‹ˆë‹¤.' : 'ë¬´ë¥´ê¸°ë¥¼ ì‹¤í–‰í–ˆìŠµë‹ˆë‹¤.', 'info');
        }
        // ë‚˜ë¼ ì œì¶œ í•¨ìˆ˜ (ì§ì ‘ ë‚˜ë¼ ì´ë¦„ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒ)
        function submitCountryDirect(country) {
            if (!country) {
                showMessage('ë‚˜ë¼ ì´ë¦„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            country = country.trim();
            if (gameState.firstPlayer === 'computer' && 
                !gameState.firstTurnDone && 
                gameState.firstTurnCountry && 
                country === gameState.firstTurnCountry &&
                gameState.currentPlayer === 'user') {
                gameState.usedCountries = [country];
                gameState.lastCountry = country;
                gameState.firstPlayer = 'user'; 
                gameState.currentPlayer = 'user';
                gameState.firstTurnDone = true;
                gameState.firstTurnCountry = null;
                addToHistory(country + ' (ëºê¸°)', 'user');
                saveGameState();
                showMessage(`"${country}"ë¥¼ ëºì—ˆìŠµë‹ˆë‹¤! ì´ì œ ë‹¹ì‹ ì´ ì„ ê³µì…ë‹ˆë‹¤.`, 'success');
                updateAvailableCountries();
                updateGameInfo();
                return;
            }
            if (gameState.lastCountry === null) {
                if (!findCountry(country)) {
                    showMessage(`"${country}"ëŠ” ìœ íš¨í•œ ë‚˜ë¼ ì´ë¦„ì´ ì•„ë‹™ë‹ˆë‹¤.`, 'error');
                    return;
                }
                if (gameState.usedCountries.includes(country)) {
                    showMessage(`"${country}"ëŠ” ì´ë¯¸ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'error');
                    return;
                }
                if (!gameState.firstTurnDone && gameState.firstPlayer === 'user') {
                    gameState.firstTurnCountry = country;
                }
                gameState.usedCountries.push(country);
                gameState.lastCountry = country;
                gameState.currentPlayer = 'computer';
                if (!gameState.firstTurnDone) {
                    gameState.firstTurnDone = true;
                    disableGameSettings();
                }
                
                // ë°ì´í„° ìˆ˜ì§‘
                if (dataCollectionEnabled) {
                    const available = getAvailableCountries([], null);
                    collectGameData(country, [], null, available);
                    updateModelStatus();
                    
                    // ì¶©ë¶„í•œ ë°ì´í„°ê°€ ëª¨ì´ë©´ ìë™ í•™ìŠµ
                    if (trainingData.length >= 50 && trainingData.length % 50 === 0 && !isTraining && !aiModel) {
                        setTimeout(async () => {
                            showMessage(`${trainingData.length}ê°œì˜ ë°ì´í„°ê°€ ìˆ˜ì§‘ë˜ì—ˆìŠµë‹ˆë‹¤. ìë™ í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤...`, 'info');
                            await trainModel(30);
                        }, 500);
                    } else if (trainingData.length >= 100 && trainingData.length % 100 === 0 && !isTraining && aiModel) {
                        setTimeout(async () => {
                            showMessage(`${trainingData.length}ê°œì˜ ë°ì´í„°ë¡œ ëª¨ë¸ì„ ì¬í•™ìŠµí•©ë‹ˆë‹¤...`, 'info');
                            await trainModel(20);
                        }, 500);
                    }
                }
                
                addToHistory(country, 'user');
                saveGameState();
                showMessage(`ì¢‹ìŠµë‹ˆë‹¤! "${country}" ë‹¤ìŒì— ì˜¬ ìˆ˜ ìˆëŠ” ë‚˜ë¼ë¥¼ ì°¾ì•„ë³´ì„¸ìš”.`, 'success');
                updateAvailableCountries();
                updateGameInfo();
                setTimeout(() => {
                    computerTurn();
                }, 100);
                return;
            }
            const lastInitial = getLastCharInitial(gameState.lastCountry);
            const currentInitial = getFirstCharInitial(country);
            if (lastInitial !== currentInitial) {
                showMessage(`"${gameState.lastCountry}"ì˜ ë§ˆì§€ë§‰ ê¸€ì(${lastInitial})ë¡œ ì‹œì‘í•˜ëŠ” ë‚˜ë¼ë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.`, 'error');
                return;
            }
            if (!findCountry(country)) {
                showMessage(`"${country}"ëŠ” ìœ íš¨í•œ ë‚˜ë¼ ì´ë¦„ì´ ì•„ë‹™ë‹ˆë‹¤.`, 'error');
                return;
            }
            if (gameState.usedCountries.includes(country)) {
                showMessage(`"${country}"ëŠ” ì´ë¯¸ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'error');
                return;
            }
            gameState.usedCountries.push(country);
            gameState.lastCountry = country;
            gameState.currentPlayer = 'computer';
            
            // ë°ì´í„° ìˆ˜ì§‘
            if (dataCollectionEnabled) {
                const available = getAvailableCountries(gameState.usedCountries.slice(0, -1), gameState.lastCountry);
                collectGameData(country, gameState.usedCountries.slice(0, -1), gameState.lastCountry, available);
                updateModelStatus();
                
                // ì¶©ë¶„í•œ ë°ì´í„°ê°€ ëª¨ì´ë©´ ìë™ í•™ìŠµ (ì¤‘ë³µ ë°©ì§€)
                if (!isTraining && trainingData.length >= 50 && trainingData.length - lastAutoTrainCount >= 50) {
                    if (!aiModel) {
                        setTimeout(async () => {
                            showMessage(`${trainingData.length}ê°œì˜ ë°ì´í„°ê°€ ìˆ˜ì§‘ë˜ì—ˆìŠµë‹ˆë‹¤. ìë™ í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤...`, 'info');
                            const success = await trainModel(30);
                            if (success) {
                                lastAutoTrainCount = trainingData.length;
                            }
                        }, 500);
                    } else if (trainingData.length >= 100 && trainingData.length - lastAutoTrainCount >= 100) {
                        setTimeout(async () => {
                            showMessage(`${trainingData.length}ê°œì˜ ë°ì´í„°ë¡œ ëª¨ë¸ì„ ì¬í•™ìŠµí•©ë‹ˆë‹¤...`, 'info');
                            const success = await trainModel(20);
                            if (success) {
                                lastAutoTrainCount = trainingData.length;
                            }
                        }, 500);
                    }
                }
            }
            
            addToHistory(country, 'user');
            saveGameState();
            showMessage(`ì •ë‹µì…ë‹ˆë‹¤! "${country}" ë‹¤ìŒì— ì˜¬ ìˆ˜ ìˆëŠ” ë‚˜ë¼ë¥¼ ì°¾ì•„ë³´ì„¸ìš”.`, 'success');
            input.value = '';
            updateAvailableCountries();
            setTimeout(() => {
                computerTurn();
            }, 100);
        }
        function chooseStrategicCountry(available) {
            const grenadaUsed = gameState.usedCountries.includes('ê·¸ë ˆë‚˜ë‹¤');
            if (gameState.lastCountry && gameState.currentPlayer === 'computer') {
                const availableWithLastCountry = [...available, gameState.lastCountry];
                const lastCountryIsLoop = isLoopCountry(gameState.lastCountry, availableWithLastCountry);
                if (lastCountryIsLoop) {
                    const loopCountries = available.filter(c => isLoopCountry(c, available));
                    if (loopCountries.length > 0) {
                        return loopCountries[Math.floor(Math.random() * loopCountries.length)];
                    }
                }
            }
            const dToGCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã„·' && last === 'ã„±';
            }).length;
            if (dToGCount === 1 && !grenadaUsed) {
                const dEnding = available.filter(c => getLastCharInitial(c) === 'ã„·');
                if (dEnding.length > 0) {
                    return dEnding[0];
                }
            }
            const rToYCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã„¹' && last === 'ã…‡';
            }).length;
            const yToRCount = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã…‡' && last === 'ã„¹';
            }).length;
            if (rToYCount - yToRCount > 0) {
                const rEnding = available.filter(c => getLastCharInitial(c) === 'ã„¹');
                if (rEnding.length > 0) {
                    return rEnding[0];
                }
            }
            const dToGUsed = gameState.usedCountries.filter(c => {
                const first = getFirstCharInitial(c);
                const last = getLastCharInitial(c);
                return first === 'ã„·' && last === 'ã„±';
            });
            if (dToGUsed.length >= 2) {
                const dEnding = available.filter(c => getLastCharInitial(c) === 'ã„·');
                if (dEnding.length > 0) {
                    if (dEnding.includes('ê·¸ë ˆë‚˜ë‹¤') && !grenadaUsed) {
                        return 'ê·¸ë ˆë‚˜ë‹¤';
                    }
                    return dEnding[0];
                }
            }
            if (grenadaUsed && dToGUsed.length >= 1) {
                const dEnding = available.filter(c => getLastCharInitial(c) === 'ã„·');
                if (dEnding.length > 0) {
                    return dEnding[0];
                }
            }
            if (gameState.firstPlayer !== 'computer') {
                const dToGCountries = available.filter(c => {
                    const first = getFirstCharInitial(c);
                    const last = getLastCharInitial(c);
                    return first === 'ã„·' && last === 'ã„±' && !isLoopCountry(c, available);
                });
                if (dToGCountries.length > 0) {
                    const unusedDToG = dToGCountries.filter(c => !gameState.usedCountries.includes(c));
                    if (unusedDToG.length > 0) {
                        return unusedDToG[0];
                    }
                }
            }
            if (gameState.firstPlayer !== 'computer') {
                const rToYCountries = available.filter(c => {
                    const first = getFirstCharInitial(c);
                    const last = getLastCharInitial(c);
                    return first === 'ã„¹' && last === 'ã…‡' && !isLoopCountry(c, available);
                });
                if (rToYCountries.length > 0) {
                    const unusedRToY = rToYCountries.filter(c => !gameState.usedCountries.includes(c));
                    if (unusedRToY.length > 0) {
                        return unusedRToY[0];
                    }
                }
            }
            if (gameState.lastCountry === 'ë¥´ì™„ë‹¤') {
                const eastTimor = available.find(c => c === 'ë™í‹°ëª¨ë¥´');
                if (eastTimor) {
                    return eastTimor;
                }
            }
            const safeEndings = ['ã„±', 'ã„¹', 'ã…Œ', 'ã…', 'ã…']; 
            const safeEndingCountries = available.filter(c => {
                const ending = getLastCharInitial(c);
                return safeEndings.includes(ending);
            });
            const nonLoopSafe = safeEndingCountries.filter(c => !isLoopCountry(c, available));
            if (nonLoopSafe.length > 0) {
                const rEndingNonLoop = nonLoopSafe.filter(c => getLastCharInitial(c) === 'ã„¹');
                if (rEndingNonLoop.length > 0) {
                    const eastTimorUsed = gameState.usedCountries.includes('ë™í‹°ëª¨ë¥´');
                    const lesotho = rEndingNonLoop.find(c => c === 'ë ˆì†Œí† ');
                    if (lesotho && !eastTimorUsed) {
                        return lesotho;
                    }
                    if (eastTimorUsed) {
                        const rwanda = rEndingNonLoop.find(c => c === 'ë¥´ì™„ë‹¤');
                        if (rwanda) return rwanda;
                    }
                    return rEndingNonLoop[0];
                }
                return nonLoopSafe[0];
            }
            if (safeEndingCountries.length > 0) {
                const rEndingCountries = safeEndingCountries.filter(c => getLastCharInitial(c) === 'ã„¹');
                if (rEndingCountries.length > 0) {
                    const eastTimorUsed = gameState.usedCountries.includes('ë™í‹°ëª¨ë¥´');
                    const lesotho = rEndingCountries.find(c => c === 'ë ˆì†Œí† ');
                    if (lesotho && !eastTimorUsed) {
                        return lesotho;
                    }
                    if (eastTimorUsed) {
                        const rwanda = rEndingCountries.find(c => c === 'ë¥´ì™„ë‹¤');
                        if (rwanda) return rwanda;
                    }
                    return rEndingCountries[0];
                }
                return safeEndingCountries[0];
            }
            if (gameState.lastCountry && gameState.currentPlayer === 'computer') {
                const lastEnding = getLastCharInitial(gameState.lastCountry);
                if (lastEnding === 'ã„·' || lastEnding === 'ã„¹') {
                    const safeCountries = available.filter(c => {
                        const first = getFirstCharInitial(c);
                        return first !== lastEnding;
                    });
                    if (safeCountries.length > 0) {
                        available = safeCountries;
                    }
                }
            }
            if (gameState.firstPlayer !== 'computer') {
                const dEnding = available.filter(c => getLastCharInitial(c) === 'ã„·');
                const dToGInDEnding = dEnding.filter(c => {
                    const first = getFirstCharInitial(c);
                    const last = getLastCharInitial(c);
                    return first === 'ã„·' && last === 'ã„±' && !gameState.usedCountries.includes(c);
                });
                if (dToGInDEnding.length > 0) {
                    return dToGInDEnding[0];
                }
            }
            return available[Math.floor(Math.random() * available.length)];
        }
        function computerTurn() {
            const available = getAvailableCountries(gameState.usedCountries, gameState.lastCountry);
            if (available.length === 0) {
                if (!gameState.gameEnded) {
                    gameState.gameEnded = true;
                    showMessage('ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ì»´í“¨í„°ê°€ ë” ì´ìƒ ë‹µí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¹ì‹ ì´ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!', 'success');
                    recordWin();
                    
                    // AI íŒ¨ë°° ì‹œ ì „ëµ ë¶„ì„
                    if (aiModeEnabled) {
                        setTimeout(() => {
                            const analysis = analyzeDefeatStrategy();
                            displayStrategyAnalysis(analysis);
                        }, 1000);
                    }
                }
                return;
            }
            if (gameState.difficulty !== 'easy' && 
                gameState.firstPlayer === 'user' && 
                !gameState.firstTurnDone && 
                gameState.firstTurnCountry && 
                gameState.currentPlayer === 'computer') {
                const firstTurnLastInitial = getLastCharInitial(gameState.firstTurnCountry);
                if (gameState.firstTurnCountry === 'ê·¸ë ˆë‚˜ë‹¤' || gameState.firstTurnCountry === 'ê³¼í…Œë§ë¼') {
                } else if (firstTurnLastInitial === 'ã„·' || firstTurnLastInitial === 'ã„¹') {
                    const stolenCountry = gameState.firstTurnCountry;
                    gameState.usedCountries = [stolenCountry];
                    gameState.lastCountry = stolenCountry;
                    gameState.firstPlayer = 'computer'; 
                    gameState.currentPlayer = 'computer';
                    gameState.firstTurnDone = true;
                    gameState.firstTurnCountry = null;
                    addToHistory(stolenCountry + ' (ëºê¸°)', 'computer');
                    saveGameState();
                    showMessage(`ì»´í“¨í„°ê°€ "${stolenCountry}"ë¥¼ ëºì—ˆìŠµë‹ˆë‹¤! ì´ì œ ì»´í“¨í„°ê°€ ì„ ê³µì…ë‹ˆë‹¤.`, 'error');
                    updateAvailableCountries();
                    updateGameInfo();
                    return;
                }
            }
            let computerChoice;
            
            // AI ëª¨ë“œê°€ í™œì„±í™”ë˜ì–´ ìˆê³  ëª¨ë¸ì´ ìˆìœ¼ë©´ AI ì‚¬ìš©
            if (aiModeEnabled) {
                if (aiModel) {
                    computerChoice = aiChooseCountry(available, gameState.usedCountries, gameState.lastCountry);
                    if (!computerChoice) {
                        // AIê°€ ì„ íƒí•˜ì§€ ëª»í•˜ë©´ ê¸°ë³¸ ë¡œì§ ì‚¬ìš©
                        computerChoice = available[Math.floor(Math.random() * available.length)];
                    }
                } else {
                    // ëª¨ë¸ì´ ì—†ìœ¼ë©´ ëœë¤ ì„ íƒ
                    computerChoice = available[Math.floor(Math.random() * available.length)];
                }
            } else if (gameState.difficulty === 'easy') {
                computerChoice = available[Math.floor(Math.random() * available.length)];
            } else if (gameState.lastCountry === null) {
                if (gameState.difficulty === 'hell') {
                    const safeCountries = available.filter(country => {
                        if (country === 'ê³¼í…Œë§ë¼') {
                            return true;
                        }
                        const nextAvailable = COUNTRY_NAMES.filter(c => {
                            const firstInitial = getFirstCharInitial(c);
                            const lastInitial = getLastCharInitial(country);
                            return firstInitial === lastInitial && !gameState.usedCountries.includes(c);
                        });
                        const hasStealable = nextAvailable.some(c => {
                            const lastInitial = getLastCharInitial(c);
                            return lastInitial === 'ã„·' || lastInitial === 'ã„¹';
                        });
                        return !hasStealable;
                    });
                    if (safeCountries.length > 0) {
                        computerChoice = safeCountries[Math.floor(Math.random() * safeCountries.length)];
                    } else {
                        computerChoice = available[Math.floor(Math.random() * available.length)];
                    }
                } else {
                    const safeCountries = available.filter(country => {
                        if (country === 'ê³¼í…Œë§ë¼') {
                            return true;
                        }
                        const nextAvailable = COUNTRY_NAMES.filter(c => {
                            const firstInitial = getFirstCharInitial(c);
                            const lastInitial = getLastCharInitial(country);
                            return firstInitial === lastInitial && !gameState.usedCountries.includes(c);
                        });
                        const hasStealable = nextAvailable.some(c => {
                            const lastInitial = getLastCharInitial(c);
                            return lastInitial === 'ã„·' || lastInitial === 'ã„¹';
                        });
                        return !hasStealable;
                    });
                    if (safeCountries.length > 0) {
                        computerChoice = safeCountries[Math.floor(Math.random() * safeCountries.length)];
                    } else {
                        computerChoice = available[Math.floor(Math.random() * available.length)];
                    }
                }
            } else {
                if (gameState.difficulty === 'hard' || gameState.difficulty === 'hell') {
                    const rToYCount = gameState.usedCountries.filter(c => {
                        const first = getFirstCharInitial(c);
                        const last = getLastCharInitial(c);
                        return first === 'ã„¹' && last === 'ã…‡';
                    }).length;
                    const yToRCount = gameState.usedCountries.filter(c => {
                        const first = getFirstCharInitial(c);
                        const last = getLastCharInitial(c);
                        return first === 'ã…‡' && last === 'ã„¹';
                    }).length;
                    const isRWinSituation = (rToYCount - yToRCount) > 0;
                    if (isRWinSituation) {
                        const rEnding = available.filter(c => getLastCharInitial(c) === 'ã„¹');
                        if (rEnding.length > 0) {
                            computerChoice = rEnding[Math.floor(Math.random() * rEnding.length)];
                        } else {
                            const safeFromRAttack = available.filter(country => {
                                const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                return !nextAvailable.some(c => getLastCharInitial(c) === 'ã„¹');
                            });
                            if (safeFromRAttack.length > 0) {
                                if (gameState.difficulty === 'hell') {
                                    const zeroSafe = safeFromRAttack.filter(country => {
                                        const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                        const safeFromRAttackNext = nextAvailable.filter(c => {
                                            const nextNextAvailable = getAvailableCountries([...gameState.usedCountries, country, c], c);
                                            return !nextNextAvailable.some(c2 => getLastCharInitial(c2) === 'ã„¹');
                                        });
                                        return safeFromRAttackNext.length === 0;
                                    });
                                    if (zeroSafe.length > 0) {
                                        computerChoice = zeroSafe[Math.floor(Math.random() * zeroSafe.length)];
                                    } else {
                                        const depth5Safe = findSafeFromAttack(safeFromRAttack, 'ã„¹', 0, 5, gameState.usedCountries);
                                        if (depth5Safe.length > 0) {
                                            computerChoice = depth5Safe[Math.floor(Math.random() * depth5Safe.length)];
                                        } else {
                                            const minSafe = safeFromRAttack.map(country => {
                                                const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                                const safeFromRAttackNext = nextAvailable.filter(c => {
                                                    const nextNextAvailable = getAvailableCountries([...gameState.usedCountries, country, c], c);
                                                    return !nextNextAvailable.some(c2 => getLastCharInitial(c2) === 'ã„¹');
                                                });
                                                return { country, count: safeFromRAttackNext.length };
                                            }).sort((a, b) => a.count - b.count);
                                            computerChoice = minSafe[0].country;
                                        }
                                    }
                                } else {
                                    const minSafe = safeFromRAttack.map(country => {
                                        const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                        const safeFromRAttackNext = nextAvailable.filter(c => {
                                            const nextNextAvailable = getAvailableCountries([...gameState.usedCountries, country, c], c);
                                            return !nextNextAvailable.some(c2 => getLastCharInitial(c2) === 'ã„¹');
                                        });
                                        return { country, count: safeFromRAttackNext.length };
                                    }).sort((a, b) => a.count - b.count);
                                    computerChoice = minSafe[0].country;
                                }
                            } else {
                                computerChoice = available[Math.floor(Math.random() * available.length)];
                            }
                        }
                    }
                }
                if (!computerChoice && (gameState.difficulty === 'normal' || gameState.difficulty === 'hard' || gameState.difficulty === 'hell')) {
                    const grenadaUsed = gameState.usedCountries.includes('ê·¸ë ˆë‚˜ë‹¤');
                    const dToGCount = gameState.usedCountries.filter(c => {
                        const first = getFirstCharInitial(c);
                        const last = getLastCharInitial(c);
                        return first === 'ã„·' && last === 'ã„±';
                    }).length;
                    const gToDCount = gameState.usedCountries.filter(c => {
                        const first = getFirstCharInitial(c);
                        const last = getLastCharInitial(c);
                        return first === 'ã„±' && last === 'ã„·';
                    }).length;
                    const isDWinSituation = (dToGCount - gToDCount) > 0 && !grenadaUsed;
                    if (isDWinSituation && (gameState.difficulty === 'hard' || gameState.difficulty === 'hell')) {
                        const dEnding = available.filter(c => getLastCharInitial(c) === 'ã„·');
                        if (dEnding.length > 0) {
                            computerChoice = dEnding[Math.floor(Math.random() * dEnding.length)];
                        } else {
                            const safeEndings = ['ã„±', 'ã„¹', 'ã…‚', 'ã…ˆ', 'ã…‹', 'ã…Œ'];
                            const safeEndingCountries = available.filter(c => {
                                const lastInitial = getLastCharInitial(c);
                                return safeEndings.includes(lastInitial);
                            });
                            let found = false;
                            for (const country of safeEndingCountries) {
                                const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                const playerCanEndWithSafe = nextAvailable.some(c => {
                                    const lastInitial = getLastCharInitial(c);
                                    return safeEndings.includes(lastInitial);
                                });
                                if (!playerCanEndWithSafe) {
                                    computerChoice = country;
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                const oddCountCountries = safeEndingCountries.filter(country => {
                                    const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                    const playerSafeEndingCount = nextAvailable.filter(c => {
                                        const lastInitial = getLastCharInitial(c);
                                        return safeEndings.includes(lastInitial);
                                    }).length;
                                    return playerSafeEndingCount % 2 === 1;
                                });
                                if (oddCountCountries.length > 0) {
                                    const filtered = oddCountCountries.filter(country => {
                                        const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                        const playerSafeEndingCount = nextAvailable.filter(c => {
                                            const lastInitial = getLastCharInitial(c);
                                            return safeEndings.includes(lastInitial);
                                        }).length;
                                        if (playerSafeEndingCount % 2 === 1) {
                                            const computerNextAvailable = nextAvailable.filter(c => {
                                                const lastInitial = getLastCharInitial(c);
                                                return safeEndings.includes(lastInitial);
                                            });
                                            const computerCanWin = computerNextAvailable.some(c => {
                                                const cNextAvailable = getAvailableCountries([...gameState.usedCountries, country, c], c);
                                                const cPlayerSafeEndingCount = cNextAvailable.filter(c2 => {
                                                    const lastInitial = getLastCharInitial(c2);
                                                    return safeEndings.includes(lastInitial);
                                                }).length;
                                                return cPlayerSafeEndingCount % 2 === 0;
                                            });
                                            return computerCanWin;
                                        }
                                        return false;
                                    });
                                    if (filtered.length > 0) {
                                        computerChoice = filtered[Math.floor(Math.random() * filtered.length)];
                                } else {
                                    computerChoice = oddCountCountries[Math.floor(Math.random() * oddCountCountries.length)];
                                }
                            } else {
                                const safeFromDAttack = available.filter(country => {
                                    const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                    return !nextAvailable.some(c => getLastCharInitial(c) === 'ã„·');
                                });
                                if (safeFromDAttack.length > 0) {
                                    if (gameState.difficulty === 'hell') {
                                        const depth5Safe = findSafeFromAttack(safeFromDAttack, 'ã„·', 0, 5, gameState.usedCountries);
                                        if (depth5Safe.length > 0) {
                                            computerChoice = depth5Safe[Math.floor(Math.random() * depth5Safe.length)];
                                        } else {
                                            const minSafe = safeFromDAttack.map(country => {
                                                const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                                const safeFromDAttackNext = nextAvailable.filter(c => {
                                                    const nextNextAvailable = getAvailableCountries([...gameState.usedCountries, country, c], c);
                                                    return !nextNextAvailable.some(c2 => getLastCharInitial(c2) === 'ã„·');
                                                });
                                                return { country, count: safeFromDAttackNext.length };
                                            }).sort((a, b) => a.count - b.count);
                                            computerChoice = minSafe[0].country;
                                        }
                                    } else {
                                        const minSafe = safeFromDAttack.map(country => {
                                            const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                                            const safeFromDAttackNext = nextAvailable.filter(c => {
                                                const nextNextAvailable = getAvailableCountries([...gameState.usedCountries, country, c], c);
                                                return !nextNextAvailable.some(c2 => getLastCharInitial(c2) === 'ã„·');
                                            });
                                            return { country, count: safeFromDAttackNext.length };
                                        }).sort((a, b) => a.count - b.count);
                                        computerChoice = minSafe[0].country;
                                    }
                                } else {
                                    computerChoice = available[Math.floor(Math.random() * available.length)];
                                }
                            }
                        }
                    }
                }
                }
                if (!computerChoice) {
                    if (gameState.difficulty === 'hell') {
                        const safeChoices = available.filter(country => {
                            const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                            if (nextAvailable.length > 0) {
                                const allEndWithDOrR = nextAvailable.every(c => {
                                    const lastInitial = getLastCharInitial(c);
                                    return lastInitial === 'ã„·' || lastInitial === 'ã„¹';
                                });
                                return !allEndWithDOrR;
                            }
                            return true;
                        });
                        if (safeChoices.length > 0) {
                            computerChoice = safeChoices[Math.floor(Math.random() * safeChoices.length)];
                        } else {
                            computerChoice = available[Math.floor(Math.random() * available.length)];
                        }
                    } else if (gameState.difficulty === 'hard' || gameState.difficulty === 'normal') {
                        const safeChoices = available.filter(country => {
                            const nextAvailable = getAvailableCountries([...gameState.usedCountries, country], country);
                            if (nextAvailable.length > 0) {
                                const allEndWithDOrR = nextAvailable.every(c => {
                                    const lastInitial = getLastCharInitial(c);
                                    return lastInitial === 'ã„·' || lastInitial === 'ã„¹';
                                });
                                return !allEndWithDOrR;
                            }
                            return true;
                        });
                        if (safeChoices.length > 0) {
                            computerChoice = safeChoices[Math.floor(Math.random() * safeChoices.length)];
                        } else {
                            computerChoice = available[Math.floor(Math.random() * available.length)];
                        }
                    } else {
                        computerChoice = available[Math.floor(Math.random() * available.length)];
                    }
                }
            }
            gameState.usedCountries.push(computerChoice);
            gameState.lastCountry = computerChoice;
            gameState.currentPlayer = 'user';
            if (!gameState.firstTurnDone) {
                if (gameState.firstPlayer === 'computer') {
                    gameState.firstTurnCountry = computerChoice;
                }
                gameState.firstTurnDone = true;
                disableGameSettings();
            }
            
            // ë°ì´í„° ìˆ˜ì§‘ (ì»´í“¨í„° ì„ íƒ)
            if (dataCollectionEnabled) {
                const prevUsed = gameState.usedCountries.slice(0, -1);
                const prevLast = gameState.usedCountries.length > 1 ? gameState.usedCountries[gameState.usedCountries.length - 2] : null;
                collectGameData(computerChoice, prevUsed, prevLast, available);
                updateModelStatus();
                
                // ì¶©ë¶„í•œ ë°ì´í„°ê°€ ëª¨ì´ë©´ ìë™ í•™ìŠµ (ì¤‘ë³µ ë°©ì§€)
                if (!isTraining && trainingData.length >= 50 && trainingData.length - lastAutoTrainCount >= 50) {
                    if (!aiModel) {
                        // ì²« í•™ìŠµ
                        setTimeout(async () => {
                            showMessage(`${trainingData.length}ê°œì˜ ë°ì´í„°ê°€ ìˆ˜ì§‘ë˜ì—ˆìŠµë‹ˆë‹¤. ìë™ í•™ìŠµì„ ì‹œì‘í•©ë‹ˆë‹¤...`, 'info');
                            const success = await trainModel(30);
                            if (success) {
                                lastAutoTrainCount = trainingData.length;
                            }
                        }, 500);
                    } else if (trainingData.length >= 100 && trainingData.length - lastAutoTrainCount >= 100) {
                        // ì¬í•™ìŠµ
                        setTimeout(async () => {
                            showMessage(`${trainingData.length}ê°œì˜ ë°ì´í„°ë¡œ ëª¨ë¸ì„ ì¬í•™ìŠµí•©ë‹ˆë‹¤...`, 'info');
                            const success = await trainModel(20);
                            if (success) {
                                lastAutoTrainCount = trainingData.length;
                            }
                        }, 500);
                    }
                }
            }
            
            addToHistory(computerChoice, 'computer');
            saveGameState();
            updateAvailableCountries();
            const nextAvailable = getAvailableCountries(gameState.usedCountries, computerChoice);
            if (nextAvailable.length === 0) {
                if (!gameState.gameEnded) {
                    gameState.gameEnded = true;
                    showMessage('ğŸ˜¢ ì»´í“¨í„°ê°€ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ë” ì´ìƒ ë‹µí•  ìˆ˜ ìˆëŠ” ë‚˜ë¼ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
                    recordLoss();
                }
            } else {
                const nextInitial = getLastCharInitial(computerChoice);
                showMessage(`ì»´í“¨í„°: "${computerChoice}" (ë‹¤ìŒ: ${nextInitial}ë¡œ ì‹œì‘í•˜ëŠ” ë‚˜ë¼)`, 'info');
            }
        }
        function isLoopCountry(country, availableCountries) {
            const firstInitial = getFirstCharInitial(country);
            const lastInitial = getLastCharInitial(country);
            if (!firstInitial || !lastInitial) return false;
            const samePairCount = availableCountries.filter(c => {
                const cFirst = getFirstCharInitial(c);
                const cLast = getLastCharInitial(c);
                return cFirst === firstInitial && cLast === lastInitial;
            }).length;
            const reversePairCount = availableCountries.filter(c => {
                const cFirst = getFirstCharInitial(c);
                const cLast = getLastCharInitial(c);
                return cFirst === lastInitial && cLast === firstInitial;
            }).length;
            if (reversePairCount > 0) {
                const maxMatched = Math.min(samePairCount, reversePairCount);
                const samePairCountries = availableCountries.filter(c => {
                    const cFirst = getFirstCharInitial(c);
                    const cLast = getLastCharInitial(c);
                    return cFirst === firstInitial && cLast === lastInitial;
                }).sort(); 
                const countryIndex = samePairCountries.indexOf(country);
                return countryIndex < maxMatched;
            }
            return false;
        }
        function updateGameInfo() {
            const usedCount = gameState.usedCountries.length;
            const lastCountry = gameState.lastCountry || '-';
            const nextInitial = gameState.lastCountry ? (getLastCharInitial(gameState.lastCountry) || '-') : '-';
            const turnText = gameState.currentPlayer === 'user' ? 'ë‚˜' : 'ì»´í“¨í„°';
            document.getElementById('usedCount').textContent = usedCount;
            document.getElementById('lastCountryDisplay').textContent = lastCountry;
            document.getElementById('nextInitialDisplay').textContent = nextInitial;
            document.getElementById('currentTurnDisplay').textContent = `í˜„ì¬ ì°¨ë¡€: ${turnText}`;
            const usedCountMobile = document.getElementById('usedCountMobile');
            const lastCountryDisplayMobile = document.getElementById('lastCountryDisplayMobile');
            const nextInitialDisplayMobile = document.getElementById('nextInitialDisplayMobile');
            const currentTurnDisplayMobile = document.getElementById('currentTurnDisplayMobile');
            if (usedCountMobile) usedCountMobile.textContent = usedCount;
            if (lastCountryDisplayMobile) lastCountryDisplayMobile.textContent = lastCountry;
            if (nextInitialDisplayMobile) nextInitialDisplayMobile.textContent = nextInitial;
            if (currentTurnDisplayMobile) currentTurnDisplayMobile.textContent = `í˜„ì¬ ì°¨ë¡€: ${turnText}`;
        }
        function updateAvailableCountries() {
            const available = getAvailableCountries(gameState.usedCountries, gameState.lastCountry);
            const listEl = document.getElementById('availableCountriesList');
            const listElMobile = document.getElementById('availableCountriesListMobile');
            const availableCount = available.length;
            document.getElementById('availableCount').textContent = availableCount;
            const availableCountMobile = document.getElementById('availableCountMobile');
            if (availableCountMobile) availableCountMobile.textContent = availableCount;
            const emptyMessage = '<div style="grid-column: 1/-1; color: #666; text-align: center; padding: 20px;">ë” ì´ìƒ ê°€ëŠ¥í•œ ë‚˜ë¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            if (available.length === 0) {
                listEl.innerHTML = emptyMessage;
                if (listElMobile) listElMobile.innerHTML = emptyMessage;
                updateGameInfo();
                return;
            }
            const loopCountries = [];
            const seenPairs = new Set();
            const topNonLoopCountries = [];
            const bottomNonLoopCountries = [];
            
            available.forEach(country => {
                if (isLoopCountry(country, available)) {
                    loopCountries.push(country);
                } else {
                    const firstInitial = getFirstCharInitial(country);
                    const lastInitial = getLastCharInitial(country);
                    const pairKey = `${firstInitial}-${lastInitial}`;
                    
                    if (seenPairs.has(pairKey)) {
                        bottomNonLoopCountries.push(country);
                    } else {
                        seenPairs.add(pairKey);
                        topNonLoopCountries.push(country);
                    }
                }
            });
            
            const sortedCountries = [...topNonLoopCountries, ...bottomNonLoopCountries, ...loopCountries];
            const countryHTML = sortedCountries.map(country => {
                const isLoop = loopCountries.includes(country);
                const tagClass = isLoop ? 'available-country-tag' : 'available-country-tag non-loop';
                return `<div class="${tagClass}" onclick="selectCountry('${country}')">${country}</div>`;
            }).join('');
            listEl.innerHTML = countryHTML;
            if (listElMobile) listElMobile.innerHTML = countryHTML;
            updateGameInfo();
        }
        function selectCountry(country) {
            if (gameState.gameEnded) {
                return;
            }
            if (gameState.currentPlayer !== 'user') {
                return;
            }
            // ì§ì ‘ ë‚˜ë¼ ì œì¶œ
            submitCountryDirect(country);
        }
        function toggleAvailableCountries() {
            const section = document.getElementById('availableCountriesSection');
            const btn = section.querySelector('.toggle-btn');
            const list = document.getElementById('availableCountriesList');
            if (section.classList.contains('hidden')) {
                section.classList.remove('hidden');
                btn.textContent = 'ìˆ¨ê¸°ê¸°';
            } else {
                section.classList.add('hidden');
                btn.textContent = 'ë³´ê¸°';
            }
        }
        function disableGameSettings() {
            document.getElementById('difficultyBtnEasy').disabled = true;
            document.getElementById('difficultyBtnNormal').disabled = true;
            document.getElementById('difficultyBtnHard').disabled = true;
            document.getElementById('difficultyBtnHell').disabled = true;
            document.getElementById('turnBtnUser').disabled = true;
            document.getElementById('turnBtnComputer').disabled = true;
            document.getElementById('difficultyBtnEasy').style.opacity = '0.5';
            document.getElementById('difficultyBtnNormal').style.opacity = '0.5';
            document.getElementById('difficultyBtnHard').style.opacity = '0.5';
            document.getElementById('difficultyBtnHell').style.opacity = '0.5';
            document.getElementById('turnBtnUser').style.opacity = '0.5';
            document.getElementById('turnBtnComputer').style.opacity = '0.5';
        }
        function enableGameSettings() {
            document.getElementById('difficultyBtnEasy').disabled = false;
            document.getElementById('difficultyBtnNormal').disabled = false;
            document.getElementById('difficultyBtnHard').disabled = false;
            document.getElementById('difficultyBtnHell').disabled = false;
            document.getElementById('turnBtnUser').disabled = false;
            document.getElementById('turnBtnComputer').disabled = false;
            document.getElementById('difficultyBtnEasy').style.opacity = '1';
            document.getElementById('difficultyBtnNormal').style.opacity = '1';
            document.getElementById('difficultyBtnHard').style.opacity = '1';
            document.getElementById('difficultyBtnHell').style.opacity = '1';
            document.getElementById('turnBtnUser').style.opacity = '1';
            document.getElementById('turnBtnComputer').style.opacity = '1';
        }
        function startNewGame() {
            gameState.usedCountries = [];
            gameState.lastCountry = null;
            gameState.gameEnded = false;
            gameState.firstTurnDone = false;
            gameState.firstTurnCountry = null;
            gameState.currentPlayer = gameState.firstPlayer;
            gameHistory.length = 0; 
            document.getElementById('history').innerHTML = '';
            document.getElementById('countryInput').value = '';
            clearGameState();
            enableGameSettings();
            showMessage('ìƒˆ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤! ë‚˜ë¼ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'info');
            updateAvailableCountries();
            updateUndoButton();
        }
        // ì…ë ¥ ì°½ ì œê±°ë¨ - ì‚¬ìš© ê°€ëŠ¥í•œ ë‚˜ë¼ ëª©ë¡ì—ì„œ ì„ íƒ
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const overlay = document.getElementById('searchOverlay');
                if (overlay.classList.contains('show')) {
                    closeSearch();
                }
            }
        });
        function searchCountries() {
            const input = document.getElementById('searchInput');
            const initial = input.value.trim();
            const resultsEl = document.getElementById('searchResults');
            if (!initial) {
                resultsEl.innerHTML = '';
                return;
            }
            const validInitials = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
            if (!validInitials.includes(initial)) {
                resultsEl.innerHTML = '<div style="grid-column: 1/-1; color: red;">ìœ íš¨í•œ ììŒì„ ì…ë ¥í•´ì£¼ì„¸ìš” (ã„±~ã…)</div>';
                return;
            }
            const countries = findCountriesByInitial(initial);
            if (countries.length === 0) {
                resultsEl.innerHTML = '<div style="grid-column: 1/-1; color: #666;">í•´ë‹¹ ììŒìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë‚˜ë¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }
            resultsEl.innerHTML = countries.map(country => 
                `<div class="country-tag">${country}</div>`
            ).join('');
        }
    </script>
</body>
</html>
